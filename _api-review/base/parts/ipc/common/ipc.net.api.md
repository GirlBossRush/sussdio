## API Report File for "@sussudio/base/parts/ipc/common/ipc.net"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export class BufferedEmitter<T> {
    	constructor();
    	// (undocumented)
    readonly event: Event_2<T>;
    	// (undocumented)
    fire(event: T): void;
    	// (undocumented)
    flushBuffer(): void;
    	}

// @public (undocumented)
interface CancellationToken {
    	readonly isCancellationRequested: boolean;
    	readonly onCancellationRequested: (
    		listener: (e: any) => any,
    		thisArgs?: any,
    		disposables?: IDisposable[],
    	) => IDisposable;
}

// @public (undocumented)
namespace CancellationToken {
    	// (undocumented)
    function isCancellationToken(thing: unknown): thing is CancellationToken;
    	const // (undocumented)
    None: Readonly<CancellationToken>;
    	const // (undocumented)
    Cancelled: Readonly<CancellationToken>;
}

// @public (undocumented)
export class ChunkStream {
    	constructor();
    	// (undocumented)
    acceptChunk(buff: VSBuffer): void;
    	// (undocumented)
    get byteLength(): number;
    	// (undocumented)
    peek(byteCount: number): VSBuffer;
    	// (undocumented)
    read(byteCount: number): VSBuffer;
    	}

// @public (undocumented)
export class Client<TContext = string> extends IPCClient<TContext> {
    	constructor(protocol: Protocol | PersistentProtocol, id: TContext, ipcLogger?: IIPCLogger | null);
    	// (undocumented)
    dispose(): void;
    	// (undocumented)
    static fromSocket<TContext = string>(socket: ISocket, id: TContext): Client<TContext>;
    	// (undocumented)
    get onDidDispose(): Event_2<void>;
    	}

// @public (undocumented)
export const enum ConnectionHealth {
    	Good = 0,
    	Poor = 1,
}

// @public
export class ConnectionHealthChangedEvent {
    	constructor(connectionHealth: ConnectionHealth);
    	// (undocumented)
    readonly connectionHealth: ConnectionHealth;
}

// @public (undocumented)
export function connectionHealthToString(connectionHealth: ConnectionHealth): 'good' | 'poor';

// @public
abstract class Disposable implements IDisposable {
    	constructor();
    	// (undocumented)
    dispose(): void;
    	static readonly None: Readonly<IDisposable>;
    	protected _register<T extends IDisposable>(o: T): T;
    	// (undocumented)
    protected readonly _store: DisposableStore;
}

// @public
class DisposableStore implements IDisposable {
    	constructor();
    	add<T extends IDisposable>(o: T): T;
    	clear(): void;
    	// (undocumented)
    static DISABLE_DISPOSED_WARNING: boolean;
    	dispose(): void;
    	// (undocumented)
    get isDisposed(): boolean;
    	}

// @public
interface Event_2<T> {
    	// (undocumented)
    (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
}

// @public (undocumented)
namespace Event_2 {
    	const // (undocumented)
    None: Event_2<any>;
    	function accumulate<T>(event: Event_2<T>, delay?: number, disposable?: DisposableStore): Event_2<T[]>;
    	function any<T>(...events: Event_2<T>[]): Event_2<T>;
    	// (undocumented)
    function any(...events: Event_2<any>[]): Event_2<void>;
    	function buffer<T>(event: Event_2<T>, flushAfterTimeout?: boolean, _buffer?: T[]): Event_2<T>;
    	// (undocumented)
    function chain<T>(event: Event_2<T>): IChainableEvent<T>;
    	function debounce<T>(
    		event: Event_2<T>,
    		merge: (last: T | undefined, event: T) => T,
    		delay?: number,
    		leading?: boolean,
    		leakWarningThreshold?: number,
    		disposable?: DisposableStore,
    	): Event_2<T>;
    	function debounce<I, O>(
    		event: Event_2<I>,
    		merge: (last: O | undefined, event: I) => O,
    		delay?: number,
    		leading?: boolean,
    		leakWarningThreshold?: number,
    		disposable?: DisposableStore,
    	): Event_2<O>;
    	function defer(event: Event_2<unknown>, disposable?: DisposableStore): Event_2<void>;
    	// (undocumented)
    interface DOMEventEmitter {
        		// (undocumented)
        addEventListener(event: string | symbol, listener: Function): void;
        		// (undocumented)
        removeEventListener(event: string | symbol, listener: Function): void;
        	}
    	function filter<T, U>(event: Event_2<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event_2<T>;
    	// (undocumented)
    function filter<T>(event: Event_2<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event_2<T>;
    	// (undocumented)
    function filter<T, R>(event: Event_2<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event_2<R>;
    	function forEach<I>(event: Event_2<I>, each: (i: I) => void, disposable?: DisposableStore): Event_2<I>;
    	// (undocumented)
    function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map?: (...args: any[]) => T): Event_2<T>;
    	// (undocumented)
    function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map?: (...args: any[]) => T): Event_2<T>;
    	// (undocumented)
    function fromObservable<T>(obs: IObservable<T, any>, store?: DisposableStore): Event_2<T>;
    	// (undocumented)
    interface IChainableEvent<T> extends IDisposable {
        		// (undocumented)
        debounce(
        			merge: (last: T | undefined, event: T) => T,
        			delay?: number,
        			leading?: boolean,
        			leakWarningThreshold?: number,
        		): IChainableEvent<T>;
        		// (undocumented)
        debounce<R>(
        			merge: (last: R | undefined, event: T) => R,
        			delay?: number,
        			leading?: boolean,
        			leakWarningThreshold?: number,
        		): IChainableEvent<R>;
        		// (undocumented)
        event: Event_2<T>;
        		// (undocumented)
        filter(fn: (e: T) => boolean): IChainableEvent<T>;
        		// (undocumented)
        filter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;
        		// (undocumented)
        forEach(fn: (i: T) => void): IChainableEvent<T>;
        		// (undocumented)
        latch(): IChainableEvent<T>;
        		// (undocumented)
        map<O>(fn: (i: T) => O): IChainableEvent<O>;
        		// (undocumented)
        on(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
        		// (undocumented)
        once(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;
        		// (undocumented)
        reduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;
        	}
    	function latch<T>(event: Event_2<T>, equals?: (a: T, b: T) => boolean, disposable?: DisposableStore): Event_2<T>;
    	function map<I, O>(event: Event_2<I>, map: (i: I) => O, disposable?: DisposableStore): Event_2<O>;
    	// (undocumented)
    interface NodeEventEmitter {
        		// (undocumented)
        on(event: string | symbol, listener: Function): unknown;
        		// (undocumented)
        removeListener(event: string | symbol, listener: Function): unknown;
        	}
    	function once<T>(event: Event_2<T>): Event_2<T>;
    	function reduce<I, O>(
    		event: Event_2<I>,
    		merge: (last: O | undefined, event: I) => O,
    		initial?: O,
    		disposable?: DisposableStore,
    	): Event_2<O>;
    	// (undocumented)
    function runAndSubscribe<T>(event: Event_2<T>, handler: (e: T | undefined) => any): IDisposable;
    	// (undocumented)
    function runAndSubscribeWithStore<T>(
    		event: Event_2<T>,
    		handler: (e: T | undefined, disposableStore: DisposableStore) => any,
    	): IDisposable;
    	function signal<T>(event: Event_2<T>): Event_2<void>;
    	function split<T, U>(
    		event: Event_2<T | U>,
    		isT: (e: T | U) => e is T,
    		disposable?: DisposableStore,
    	): [Event_2<T>, Event_2<U>];
    	// (undocumented)
    function toPromise<T>(event: Event_2<T>): Promise<T>;
}

// @public
export class HighRoundTripTimeEvent {
    	constructor(
    		roundTripTime: number,
    		recentHighRoundTripCount: number,
    	);
    	readonly recentHighRoundTripCount: number;
    	readonly roundTripTime: number;
}

// @public
interface IChannel {
    	// (undocumented)
    call<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;
    	// (undocumented)
    listen<T>(event: string, arg?: any): Event_2<T>;
}

// @public
interface IChannelClient {
    	// (undocumented)
    getChannel<T extends IChannel>(channelName: string): T;
}

// @public
interface IChannelServer<TContext = string> {
    	// (undocumented)
    registerChannel(channelName: string, channel: IServerChannel<TContext>): void;
}

// @public
interface IDisposable {
    	// (undocumented)
    dispose(): void;
}

// @public (undocumented)
interface IIPCLogger {
    	// (undocumented)
    logIncoming(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;
    	// (undocumented)
    logOutgoing(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;
}

// @public (undocumented)
export interface ILoadEstimator {
    	// (undocumented)
    hasHighLoad(): boolean;
}

// @public (undocumented)
interface IMessagePassingProtocol {
    	drain?(): Promise<void>;
    	// (undocumented)
    onMessage: Event_2<VSBuffer>;
    	// (undocumented)
    send(buffer: VSBuffer): void;
}

// @public (undocumented)
interface IObservable<T, _TChange = void> {
    	addObserver(observer: IObserver): void;
    	// (undocumented)
    readonly debugName: string;
    	get(): T;
    	// (undocumented)
    map<TNew>(fn: (value: T) => TNew): IObservable<TNew>;
    	read(reader: IReader): T;
    	// (undocumented)
    removeObserver(observer: IObserver): void;
    	// (undocumented)
    readonly TChange: _TChange;
}

// @public (undocumented)
interface IObserver {
    	beginUpdate<T>(observable: IObservable<T>): void;
    	endUpdate<T>(observable: IObservable<T>): void;
    	handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;
}

// @public
class IPCClient<TContext = string> implements IChannelClient, IChannelServer<TContext>, IDisposable {
    	constructor(protocol: IMessagePassingProtocol, ctx: TContext, ipcLogger?: IIPCLogger | null);
    	// (undocumented)
    dispose(): void;
    	// (undocumented)
    getChannel<T extends IChannel>(channelName: string): T;
    	// (undocumented)
    registerChannel(channelName: string, channel: IServerChannel<TContext>): void;
}

// @public (undocumented)
interface IReader {
    	subscribeTo<T>(observable: IObservable<T, any>): void;
}

// @public
interface IServerChannel<TContext = string> {
    	// (undocumented)
    call<T>(ctx: TContext, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;
    	// (undocumented)
    listen<T>(ctx: TContext, event: string, arg?: any): Event_2<T>;
}

// @public (undocumented)
export interface ISocket extends IDisposable {
    	// (undocumented)
    drain(): Promise<void>;
    	// (undocumented)
    end(): void;
    	// (undocumented)
    onClose(listener: (e: SocketCloseEvent) => void): IDisposable;
    	// (undocumented)
    onData(listener: (e: VSBuffer) => void): IDisposable;
    	// (undocumented)
    onEnd(listener: () => void): IDisposable;
    	// (undocumented)
    traceSocketEvent(
    		type: SocketDiagnosticsEventType,
    		data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any,
    	): void;
    	// (undocumented)
    write(buffer: VSBuffer): void;
}

// @public (undocumented)
export interface NodeSocketCloseEvent {
    	readonly error: Error | undefined;
    	readonly hadError: boolean;
    	readonly type: SocketCloseEventType.NodeSocketCloseEvent;
}

// @public
export class PersistentProtocol implements IMessagePassingProtocol {
    	constructor(opts: PersistentProtocolOptions);
    	// (undocumented)
    acceptDisconnect(): void;
    	// (undocumented)
    beginAcceptReconnection(socket: ISocket, initialDataChunk: VSBuffer | null): void;
    	// (undocumented)
    dispose(): void;
    	// (undocumented)
    drain(): Promise<void>;
    	// (undocumented)
    endAcceptReconnection(): void;
    	// (undocumented)
    flush(): void;
    	// (undocumented)
    getMillisSinceLastIncomingData(): number;
    	// (undocumented)
    getSocket(): ISocket;
    	// (undocumented)
    readonly onControlMessage: Event_2<VSBuffer>;
    	// (undocumented)
    readonly onDidChangeConnectionHealth: Event_2<ConnectionHealth>;
    	// (undocumented)
    readonly onDidDispose: Event_2<void>;
    	// (undocumented)
    readonly onHighRoundTripTime: Event_2<HighRoundTripTimeEvent>;
    	// (undocumented)
    readonly onMessage: Event_2<VSBuffer>;
    	// (undocumented)
    readonly onSocketClose: Event_2<SocketCloseEvent>;
    	// (undocumented)
    readonly onSocketTimeout: Event_2<SocketTimeoutEvent>;
    	// (undocumented)
    pauseSocketWriting(): void;
    	// (undocumented)
    readEntireBuffer(): VSBuffer;
    	// (undocumented)
    send(buffer: VSBuffer): void;
    	sendControl(buffer: VSBuffer): void;
    	// (undocumented)
    sendDisconnect(): void;
    	// (undocumented)
    sendPause(): void;
    	// (undocumented)
    sendResume(): void;
    	// (undocumented)
    get unacknowledgedCount(): number;
}

// @public (undocumented)
export interface PersistentProtocolOptions {
    	initialChunk?: VSBuffer | null;
    	loadEstimator?: ILoadEstimator;
    	measureRoundTripTime?: boolean;
    	sendKeepAlive?: boolean;
    	socket: ISocket;
}

// @public
export class Protocol extends Disposable implements IMessagePassingProtocol {
    	constructor(socket: ISocket);
    	// (undocumented)
    drain(): Promise<void>;
    	// (undocumented)
    getSocket(): ISocket;
    	// (undocumented)
    readonly onDidDispose: Event_2<void>;
    	// (undocumented)
    readonly onMessage: Event_2<VSBuffer>;
    	// (undocumented)
    send(buffer: VSBuffer): void;
    	// (undocumented)
    sendDisconnect(): void;
    	}

// @public (undocumented)
export const enum ProtocolConstants {
    	AcknowledgeTime = 2000,
    	// (undocumented)
    HeaderLength = 13,
    	HighLatencySampleThreshold = 3,
    	HighLatencyTimeThreshold = 1000,
    	KeepAliveSendTime = 5000,
    	LatencySampleCount = 5,
    	LatencySampleTime = 60000,
    	ReconnectionGraceTime = 10800000,
    	ReconnectionShortGraceTime = 300000,
    	TimeoutTime = 20000,
}

// @public (undocumented)
const enum RequestInitiator {
    	// (undocumented)
    LocalSide = 0,
    	// (undocumented)
    OtherSide = 1,
}

// @public (undocumented)
export type SocketCloseEvent = NodeSocketCloseEvent | WebSocketCloseEvent | undefined;

// @public (undocumented)
export const enum SocketCloseEventType {
    	// (undocumented)
    NodeSocketCloseEvent = 0,
    	// (undocumented)
    WebSocketCloseEvent = 1,
}

// @public (undocumented)
export namespace SocketDiagnostics {
    	const // (undocumented)
    enableDiagnostics = false;
    	// (undocumented)
    export interface IRecord {
        		// (undocumented)
        buff?: VSBuffer;
        		// (undocumented)
        data?: any;
        		// (undocumented)
        id: string;
        		// (undocumented)
        label: string;
        		// (undocumented)
        timestamp: number;
        		// (undocumented)
        type: SocketDiagnosticsEventType;
        	}
    	const // (undocumented)
    records: IRecord[];
    	// (undocumented)
    export function traceSocketEvent(
    		nativeObject: any,
    		socketDebugLabel: string,
    		type: SocketDiagnosticsEventType,
    		data?: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView | any,
    	): void;
}

// @public (undocumented)
export const enum SocketDiagnosticsEventType {
    	// (undocumented)
    BrowserWebSocketBlobReceived = 'browserWebSocketBlobReceived',
    	// (undocumented)
    Close = 'close',
    	// (undocumented)
    Created = 'created',
    	// (undocumented)
    Error = 'error',
    	// (undocumented)
    NodeDrainBegin = 'nodeDrainBegin',
    	// (undocumented)
    NodeDrainEnd = 'nodeDrainEnd',
    	// (undocumented)
    NodeEndReceived = 'nodeEndReceived',
    	// (undocumented)
    NodeEndSent = 'nodeEndSent',
    	// (undocumented)
    Open = 'open',
    	// (undocumented)
    ProtocolHeaderRead = 'protocolHeaderRead',
    	// (undocumented)
    ProtocolHeaderWrite = 'protocolHeaderWrite',
    	// (undocumented)
    ProtocolMessageRead = 'protocolMessageRead',
    	// (undocumented)
    ProtocolMessageWrite = 'protocolMessageWrite',
    	// (undocumented)
    ProtocolWrite = 'protocolWrite',
    	// (undocumented)
    Read = 'read',
    	// (undocumented)
    WebSocketNodeSocketDrainBegin = 'webSocketNodeSocketDrainBegin',
    	// (undocumented)
    WebSocketNodeSocketDrainEnd = 'webSocketNodeSocketDrainEnd',
    	// (undocumented)
    WebSocketNodeSocketPeekedHeader = 'webSocketNodeSocketPeekedHeader',
    	// (undocumented)
    WebSocketNodeSocketReadData = 'webSocketNodeSocketReadData',
    	// (undocumented)
    WebSocketNodeSocketReadHeader = 'webSocketNodeSocketReadHeader',
    	// (undocumented)
    WebSocketNodeSocketUnmaskedData = 'webSocketNodeSocketUnmaskedData',
    	// (undocumented)
    WebSocketNodeSocketWrite = 'webSocketNodeSocketWrite',
    	// (undocumented)
    Write = 'write',
    	// (undocumented)
    zlibDeflateData = 'zlibDeflateData',
    	// (undocumented)
    zlibDeflateError = 'zlibDeflateError',
    	// (undocumented)
    zlibDeflateFlushFired = 'zlibDeflateFlushFired',
    	// (undocumented)
    zlibDeflateWrite = 'zlibDeflateWrite',
    	// (undocumented)
    zlibInflateData = 'zlibInflateData',
    	// (undocumented)
    zlibInflateError = 'zlibInflateError',
    	// (undocumented)
    zlibInflateFlushFired = 'zlibInflateFlushFired',
    	// (undocumented)
    zlibInflateInitialFlushFired = 'zlibInflateInitialFlushFired',
    	// (undocumented)
    zlibInflateInitialWrite = 'zlibInflateInitialWrite',
    	// (undocumented)
    zlibInflateWrite = 'zlibInflateWrite',
}

// @public (undocumented)
export interface SocketTimeoutEvent {
    	// (undocumented)
    readonly timeSinceLastReceivedSomeData: number;
    	// (undocumented)
    readonly timeSinceOldestUnacknowledgedMsg: number;
    	// (undocumented)
    readonly unacknowledgedMsgCount: number;
}

// @public (undocumented)
class VSBuffer {
    	static alloc(byteLength: number): VSBuffer;
    	// (undocumented)
    readonly buffer: Uint8Array;
    	// (undocumented)
    readonly byteLength: number;
    	clone(): VSBuffer;
    	static concat(buffers: VSBuffer[], totalLength?: number): VSBuffer;
    	static fromByteArray(source: number[]): VSBuffer;
    	static fromString(
    		source: string,
    		options?: {
        			dontUseNodeBuffer?: boolean;
        		},
    	): VSBuffer;
    	// (undocumented)
    readUInt32BE(offset: number): number;
    	// (undocumented)
    readUInt32LE(offset: number): number;
    	// (undocumented)
    readUInt8(offset: number): number;
    	// (undocumented)
    set(array: VSBuffer, offset?: number): void;
    	// (undocumented)
    set(array: Uint8Array, offset?: number): void;
    	// (undocumented)
    set(array: ArrayBuffer, offset?: number): void;
    	// (undocumented)
    set(array: ArrayBufferView, offset?: number): void;
    	// (undocumented)
    set(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void;
    	// (undocumented)
    slice(start?: number, end?: number): VSBuffer;
    	// (undocumented)
    toString(): string;
    	static wrap(actual: Uint8Array): VSBuffer;
    	// (undocumented)
    writeUInt32BE(value: number, offset: number): void;
    	// (undocumented)
    writeUInt32LE(value: number, offset: number): void;
    	// (undocumented)
    writeUInt8(value: number, offset: number): void;
}

// @public (undocumented)
export interface WebSocketCloseEvent {
    	readonly code: number;
    	readonly event: any | undefined;
    	readonly reason: string;
    	readonly type: SocketCloseEventType.WebSocketCloseEvent;
    	readonly wasClean: boolean;
}

// (No @packageDocumentation comment for this package)

```
