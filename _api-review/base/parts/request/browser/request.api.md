## API Report File for "@sussudio/base/parts/request/browser/request"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
interface CancellationToken {
    	readonly isCancellationRequested: boolean;
    	readonly onCancellationRequested: (
    		listener: (e: any) => any,
    		thisArgs?: any,
    		disposables?: IDisposable[],
    	) => IDisposable;
}

// @public (undocumented)
namespace CancellationToken {
    	// (undocumented)
    function isCancellationToken(thing: unknown): thing is CancellationToken;
    	const // (undocumented)
    None: Readonly<CancellationToken>;
    	const // (undocumented)
    Cancelled: Readonly<CancellationToken>;
}

// @public
function consumeReadable<T>(readable: Readable<T>, reducer: IReducer<T>): T;

// @public
function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer: IReducer<T, R>): Promise<R>;

// @public (undocumented)
function consumeStream(stream: ReadableStreamEvents<unknown>): Promise<undefined>;

// @public
function emptyStream(): ReadableStream_2<never>;

// @public (undocumented)
interface IDataTransformer<Original, Transformed> {
    	// (undocumented)
    (data: Original): Transformed;
}

// @public
interface IDisposable {
    	// (undocumented)
    dispose(): void;
}

// @public (undocumented)
interface IErrorTransformer {
    	// (undocumented)
    (error: Error): Error;
}

// @public (undocumented)
interface IHeaders {
    	// (undocumented)
    [header: string]: string;
}

// @public (undocumented)
interface IReducer<T, R = T> {
    	// (undocumented)
    (data: T[]): R;
}

// @public (undocumented)
interface IRequestContext {
    	// (undocumented)
    res: {
        		headers: IHeaders;
        		statusCode?: number;
        	};
    	// (undocumented)
    stream: VSBufferReadableStream;
}

// @public (undocumented)
interface IRequestOptions {
    	// (undocumented)
    data?: string;
    	// (undocumented)
    followRedirects?: number;
    	// (undocumented)
    headers?: IHeaders;
    	// (undocumented)
    password?: string;
    	// (undocumented)
    proxyAuthorization?: string;
    	// (undocumented)
    timeout?: number;
    	// (undocumented)
    type?: string;
    	// (undocumented)
    url?: string;
    	// (undocumented)
    user?: string;
}

// @public (undocumented)
function isReadable<T>(obj: unknown): obj is Readable<T>;

// @public (undocumented)
function isReadableBufferedStream<T>(obj: unknown): obj is ReadableBufferedStream<T>;

// @public (undocumented)
function isReadableStream<T>(obj: unknown): obj is ReadableStream_2<T>;

// @public (undocumented)
interface IStreamListener<T> {
    	onData(data: T): void;
    	onEnd(): void;
    	onError(err: Error): void;
}

// @public (undocumented)
interface ITransformer<Original, Transformed> {
    	// (undocumented)
    data: IDataTransformer<Original, Transformed>;
    	// (undocumented)
    error?: IErrorTransformer;
}

// @public
function listenStream<T>(stream: ReadableStreamEvents<T>, listener: IStreamListener<T>): IDisposable;

// @public (undocumented)
function newWriteableStream<T>(
	reducer: IReducer<T>,
	options?: WriteableStreamOptions,
): WriteableStream<T>;

// @public
function peekReadable<T>(
	readable: Readable<T>,
	reducer: IReducer<T>,
	maxChunks: number,
): T | Readable<T>;

// @public
function peekStream<T>(stream: ReadableStream_2<T>, maxChunks: number): Promise<ReadableBufferedStream<T>>;

// @public
function prefixedReadable<T>(prefix: T, readable: Readable<T>, reducer: IReducer<T>): Readable<T>;

// @public
function prefixedStream<T>(
	prefix: T,
	stream: ReadableStream_2<T>,
	reducer: IReducer<T>,
): ReadableStream_2<T>;

// @public
interface Readable<T> {
    	read(): T | null;
}

// @public
interface ReadableBufferedStream<T> {
    	buffer: T[];
    	ended: boolean;
    	stream: ReadableStream_2<T>;
}

// @public
interface ReadableStream_2<T> extends ReadableStreamEvents<T> {
    	destroy(): void;
    	pause(): void;
    	removeListener(event: string, callback: Function): void;
    	resume(): void;
}

// @public
type ReadableStreamEventPayload<T> = T | Error | 'end';

// @public (undocumented)
interface ReadableStreamEvents<T> {
    	on(event: 'data', callback: (data: T) => void): void;
    	on(event: 'error', callback: (err: Error) => void): void;
    	on(event: 'end', callback: () => void): void;
}

// @public (undocumented)
export function request(options: IRequestOptions, token: CancellationToken): Promise<IRequestContext>;

declare namespace streams {
    export {
        isReadable,
        isReadableStream,
        isReadableBufferedStream,
        newWriteableStream,
        consumeReadable,
        peekReadable,
        consumeStream,
        listenStream,
        peekStream,
        toStream,
        emptyStream,
        toReadable,
        transform,
        prefixedReadable,
        prefixedStream,
        ReadableStreamEventPayload,
        ReadableStreamEvents,
        ReadableStream_2 as ReadableStream,
        Readable,
        WriteableStream,
        ReadableBufferedStream,
        IReducer,
        IDataTransformer,
        IErrorTransformer,
        ITransformer,
        WriteableStreamOptions,
        IStreamListener
    }
}

// @public
function toReadable<T>(t: T): Readable<T>;

// @public
function toStream<T>(t: T, reducer: IReducer<T>): ReadableStream_2<T>;

// @public
function transform<Original, Transformed>(
	stream: ReadableStreamEvents<Original>,
	transformer: ITransformer<Original, Transformed>,
	reducer: IReducer<Transformed>,
): ReadableStream_2<Transformed>;

// @public (undocumented)
class VSBuffer {
    	static alloc(byteLength: number): VSBuffer;
    	// (undocumented)
    readonly buffer: Uint8Array;
    	// (undocumented)
    readonly byteLength: number;
    	clone(): VSBuffer;
    	static concat(buffers: VSBuffer[], totalLength?: number): VSBuffer;
    	static fromByteArray(source: number[]): VSBuffer;
    	static fromString(
    		source: string,
    		options?: {
        			dontUseNodeBuffer?: boolean;
        		},
    	): VSBuffer;
    	// (undocumented)
    readUInt32BE(offset: number): number;
    	// (undocumented)
    readUInt32LE(offset: number): number;
    	// (undocumented)
    readUInt8(offset: number): number;
    	// (undocumented)
    set(array: VSBuffer, offset?: number): void;
    	// (undocumented)
    set(array: Uint8Array, offset?: number): void;
    	// (undocumented)
    set(array: ArrayBuffer, offset?: number): void;
    	// (undocumented)
    set(array: ArrayBufferView, offset?: number): void;
    	// (undocumented)
    set(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void;
    	// (undocumented)
    slice(start?: number, end?: number): VSBuffer;
    	// (undocumented)
    toString(): string;
    	static wrap(actual: Uint8Array): VSBuffer;
    	// (undocumented)
    writeUInt32BE(value: number, offset: number): void;
    	// (undocumented)
    writeUInt32LE(value: number, offset: number): void;
    	// (undocumented)
    writeUInt8(value: number, offset: number): void;
}

// @public (undocumented)
interface VSBufferReadableStream extends streams.ReadableStream<VSBuffer> {}

// @public
interface WriteableStream<T> extends ReadableStream_2<T> {
    	end(result?: T): void;
    	error(error: Error): void;
    	write(data: T): void | Promise<void>;
}

// @public (undocumented)
interface WriteableStreamOptions {
    	highWaterMark?: number;
}

// (No @packageDocumentation comment for this package)

```
