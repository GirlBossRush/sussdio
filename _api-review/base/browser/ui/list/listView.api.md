## API Report File for "@sussudio/base/browser/ui/list/listView"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
type AriaRole =
	| 'alert'
	| 'alertdialog'
	| 'application'
	| 'article'
	| 'banner'
	| 'button'
	| 'cell'
	| 'checkbox'
	| 'columnheader'
	| 'combobox'
	| 'complementary'
	| 'contentinfo'
	| 'definition'
	| 'dialog'
	| 'directory'
	| 'document'
	| 'feed'
	| 'figure'
	| 'form'
	| 'grid'
	| 'gridcell'
	| 'group'
	| 'heading'
	| 'img'
	| 'link'
	| 'list'
	| 'listbox'
	| 'listitem'
	| 'log'
	| 'main'
	| 'marquee'
	| 'math'
	| 'menu'
	| 'menubar'
	| 'menuitem'
	| 'menuitemcheckbox'
	| 'menuitemradio'
	| 'navigation'
	| 'none'
	| 'note'
	| 'option'
	| 'presentation'
	| 'progressbar'
	| 'radio'
	| 'radiogroup'
	| 'region'
	| 'row'
	| 'rowgroup'
	| 'rowheader'
	| 'scrollbar'
	| 'search'
	| 'searchbox'
	| 'separator'
	| 'slider'
	| 'spinbutton'
	| 'status'
	| 'switch'
	| 'tab'
	| 'table'
	| 'tablist'
	| 'tabpanel'
	| 'term'
	| 'textbox'
	| 'timer'
	| 'toolbar'
	| 'tooltip'
	| 'tree'
	| 'treegrid'
	| 'treeitem'
	| (string & {});

// @public (undocumented)
class Dimension implements IDimension {
    	constructor(width: number, height: number);
    	// (undocumented)
    static equals(a: Dimension | undefined, b: Dimension | undefined): boolean;
    	// (undocumented)
    readonly height: number;
    	// (undocumented)
    static is(obj: unknown): obj is IDimension;
    	// (undocumented)
    static lift(obj: IDimension): Dimension;
    	// (undocumented)
    static readonly None: Dimension;
    	// (undocumented)
    readonly width: number;
    	// (undocumented)
    with(width?: number, height?: number): Dimension;
}

// @public
class DisposableStore implements IDisposable {
    	constructor();
    	add<T extends IDisposable>(o: T): T;
    	clear(): void;
    	// (undocumented)
    static DISABLE_DISPOSED_WARNING: boolean;
    	dispose(): void;
    	// (undocumented)
    get isDisposed(): boolean;
    	}

// @public (undocumented)
export class ElementsDragAndDropData<T, TContext = void> implements IDragAndDropData {
    	constructor(elements: T[]);
    	// (undocumented)
    get context(): TContext | undefined;
    	set context(value: TContext | undefined);
    	// (undocumented)
    readonly elements: T[];
    	// (undocumented)
    getData(): T[];
    	// (undocumented)
    update(): void;
}

// @public
interface Event_2<T> {
    	// (undocumented)
    (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
}

// @public (undocumented)
namespace Event_2 {
    	const // (undocumented)
    None: Event_2<any>;
    	function accumulate<T>(event: Event_2<T>, delay?: number, disposable?: DisposableStore): Event_2<T[]>;
    	function any<T>(...events: Event_2<T>[]): Event_2<T>;
    	// (undocumented)
    function any(...events: Event_2<any>[]): Event_2<void>;
    	function buffer<T>(event: Event_2<T>, flushAfterTimeout?: boolean, _buffer?: T[]): Event_2<T>;
    	// (undocumented)
    function chain<T>(event: Event_2<T>): IChainableEvent<T>;
    	function debounce<T>(
    		event: Event_2<T>,
    		merge: (last: T | undefined, event: T) => T,
    		delay?: number,
    		leading?: boolean,
    		leakWarningThreshold?: number,
    		disposable?: DisposableStore,
    	): Event_2<T>;
    	function debounce<I, O>(
    		event: Event_2<I>,
    		merge: (last: O | undefined, event: I) => O,
    		delay?: number,
    		leading?: boolean,
    		leakWarningThreshold?: number,
    		disposable?: DisposableStore,
    	): Event_2<O>;
    	function defer(event: Event_2<unknown>, disposable?: DisposableStore): Event_2<void>;
    	// (undocumented)
    interface DOMEventEmitter {
        		// (undocumented)
        addEventListener(event: string | symbol, listener: Function): void;
        		// (undocumented)
        removeEventListener(event: string | symbol, listener: Function): void;
        	}
    	function filter<T, U>(event: Event_2<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event_2<T>;
    	// (undocumented)
    function filter<T>(event: Event_2<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event_2<T>;
    	// (undocumented)
    function filter<T, R>(event: Event_2<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event_2<R>;
    	function forEach<I>(event: Event_2<I>, each: (i: I) => void, disposable?: DisposableStore): Event_2<I>;
    	// (undocumented)
    function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map?: (...args: any[]) => T): Event_2<T>;
    	// (undocumented)
    function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map?: (...args: any[]) => T): Event_2<T>;
    	// (undocumented)
    function fromObservable<T>(obs: IObservable<T, any>, store?: DisposableStore): Event_2<T>;
    	// (undocumented)
    interface IChainableEvent<T> extends IDisposable {
        		// (undocumented)
        debounce(
        			merge: (last: T | undefined, event: T) => T,
        			delay?: number,
        			leading?: boolean,
        			leakWarningThreshold?: number,
        		): IChainableEvent<T>;
        		// (undocumented)
        debounce<R>(
        			merge: (last: R | undefined, event: T) => R,
        			delay?: number,
        			leading?: boolean,
        			leakWarningThreshold?: number,
        		): IChainableEvent<R>;
        		// (undocumented)
        event: Event_2<T>;
        		// (undocumented)
        filter(fn: (e: T) => boolean): IChainableEvent<T>;
        		// (undocumented)
        filter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;
        		// (undocumented)
        forEach(fn: (i: T) => void): IChainableEvent<T>;
        		// (undocumented)
        latch(): IChainableEvent<T>;
        		// (undocumented)
        map<O>(fn: (i: T) => O): IChainableEvent<O>;
        		// (undocumented)
        on(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
        		// (undocumented)
        once(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;
        		// (undocumented)
        reduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;
        	}
    	function latch<T>(event: Event_2<T>, equals?: (a: T, b: T) => boolean, disposable?: DisposableStore): Event_2<T>;
    	function map<I, O>(event: Event_2<I>, map: (i: I) => O, disposable?: DisposableStore): Event_2<O>;
    	// (undocumented)
    interface NodeEventEmitter {
        		// (undocumented)
        on(event: string | symbol, listener: Function): unknown;
        		// (undocumented)
        removeListener(event: string | symbol, listener: Function): unknown;
        	}
    	function once<T>(event: Event_2<T>): Event_2<T>;
    	function reduce<I, O>(
    		event: Event_2<I>,
    		merge: (last: O | undefined, event: I) => O,
    		initial?: O,
    		disposable?: DisposableStore,
    	): Event_2<O>;
    	// (undocumented)
    function runAndSubscribe<T>(event: Event_2<T>, handler: (e: T | undefined) => any): IDisposable;
    	// (undocumented)
    function runAndSubscribeWithStore<T>(
    		event: Event_2<T>,
    		handler: (e: T | undefined, disposableStore: DisposableStore) => any,
    	): IDisposable;
    	function signal<T>(event: Event_2<T>): Event_2<void>;
    	function split<T, U>(
    		event: Event_2<T | U>,
    		isT: (e: T | U) => e is T,
    		disposable?: DisposableStore,
    	): [Event_2<T>, Event_2<U>];
    	// (undocumented)
    function toPromise<T>(event: Event_2<T>): Promise<T>;
}

// @public (undocumented)
export class ExternalElementsDragAndDropData<T> implements IDragAndDropData {
    	constructor(elements: T[]);
    	// (undocumented)
    readonly elements: T[];
    	// (undocumented)
    getData(): T[];
    	// (undocumented)
    update(): void;
}

// @public (undocumented)
interface GestureEvent extends MouseEvent {
    	// (undocumented)
    initialTarget: EventTarget | undefined;
    	// (undocumented)
    pageX: number;
    	// (undocumented)
    pageY: number;
    	// (undocumented)
    tapCount: number;
    	// (undocumented)
    translationX: number;
    	// (undocumented)
    translationY: number;
}

// @public (undocumented)
interface IDimension {
    	// (undocumented)
    readonly height: number;
    	// (undocumented)
    readonly width: number;
}

// @public
interface IDisposable {
    	// (undocumented)
    dispose(): void;
}

// @public (undocumented)
interface IDragAndDropData {
    	// (undocumented)
    getData(): unknown;
    	// (undocumented)
    update(dataTransfer: DataTransfer): void;
}

// @public (undocumented)
interface IListDragAndDrop<T> {
    	// (undocumented)
    drop(
    		data: IDragAndDropData,
    		targetElement: T | undefined,
    		targetIndex: number | undefined,
    		originalEvent: DragEvent,
    	): void;
    	// (undocumented)
    getDragLabel?(elements: T[], originalEvent: DragEvent): string | undefined;
    	// (undocumented)
    getDragURI(element: T): string | null;
    	// (undocumented)
    onDragEnd?(originalEvent: DragEvent): void;
    	// (undocumented)
    onDragLeave?(
    		data: IDragAndDropData,
    		targetElement: T | undefined,
    		targetIndex: number | undefined,
    		originalEvent: DragEvent,
    	): void;
    	// (undocumented)
    onDragOver(
    		data: IDragAndDropData,
    		targetElement: T | undefined,
    		targetIndex: number | undefined,
    		originalEvent: DragEvent,
    	): boolean | IListDragOverReaction;
    	// (undocumented)
    onDragStart?(data: IDragAndDropData, originalEvent: DragEvent): void;
}

// @public (undocumented)
interface IListDragOverReaction {
    	// (undocumented)
    accept: boolean;
    	// (undocumented)
    effect?: ListDragOverEffect;
    	// (undocumented)
    feedback?: number[];
}

// @public (undocumented)
interface IListGestureEvent<T> {
    	// (undocumented)
    browserEvent: GestureEvent;
    	// (undocumented)
    element: T | undefined;
    	// (undocumented)
    index: number | undefined;
}

// @public (undocumented)
interface IListMouseEvent<T> {
    	// (undocumented)
    browserEvent: MouseEvent;
    	// (undocumented)
    element: T | undefined;
    	// (undocumented)
    index: number | undefined;
}

// @public (undocumented)
interface IListRenderer<T, TTemplateData> {
    	// (undocumented)
    disposeElement?(element: T, index: number, templateData: TTemplateData, height: number | undefined): void;
    	// (undocumented)
    disposeTemplate(templateData: TTemplateData): void;
    	// (undocumented)
    renderElement(element: T, index: number, templateData: TTemplateData, height: number | undefined): void;
    	// (undocumented)
    renderTemplate(container: HTMLElement): TTemplateData;
    	// (undocumented)
    readonly templateId: string;
}

// @public (undocumented)
interface IListTouchEvent<T> {
    	// (undocumented)
    browserEvent: TouchEvent;
    	// (undocumented)
    element: T | undefined;
    	// (undocumented)
    index: number | undefined;
}

// @public (undocumented)
export interface IListViewAccessibilityProvider<T> {
    	// (undocumented)
    getPosInSet?(element: T, index: number): number;
    	// (undocumented)
    getRole?(element: T): AriaRole | undefined;
    	// (undocumented)
    getSetSize?(element: T, index: number, listLength: number): number;
    	// (undocumented)
    isChecked?(element: T): boolean | IObservableValue<boolean> | undefined;
}

// @public (undocumented)
export interface IListViewDragAndDrop<T> extends IListDragAndDrop<T> {
    	// (undocumented)
    getDragElements(element: T): T[];
}

// @public (undocumented)
export interface IListViewOptions<T> extends IListViewOptionsUpdate {
    	// (undocumented)
    readonly accessibilityProvider?: IListViewAccessibilityProvider<T>;
    	// (undocumented)
    readonly alwaysConsumeMouseWheel?: boolean;
    	// (undocumented)
    readonly dnd?: IListViewDragAndDrop<T>;
    	// (undocumented)
    readonly initialSize?: Dimension;
    	// (undocumented)
    readonly mouseSupport?: boolean;
    	// (undocumented)
    readonly setRowHeight?: boolean;
    	// (undocumented)
    readonly setRowLineHeight?: boolean;
    	// (undocumented)
    readonly supportDynamicHeights?: boolean;
    	// (undocumented)
    readonly transformOptimization?: boolean;
    	// (undocumented)
    readonly useShadows?: boolean;
    	// (undocumented)
    readonly verticalScrollMode?: ScrollbarVisibility;
}

// @public (undocumented)
export interface IListViewOptionsUpdate {
    	// (undocumented)
    readonly additionalScrollHeight?: number;
    	// (undocumented)
    readonly fastScrollSensitivity?: number;
    	// (undocumented)
    readonly horizontalScrolling?: boolean;
    	// (undocumented)
    readonly mouseWheelScrollSensitivity?: number;
    	// (undocumented)
    readonly smoothScrolling?: boolean;
}

// @public (undocumented)
interface IListVirtualDelegate<T> {
    	// (undocumented)
    getDynamicHeight?(element: T): number | null;
    	// (undocumented)
    getHeight(element: T): number;
    	// (undocumented)
    getTemplateId(element: T): string;
    	// (undocumented)
    hasDynamicHeight?(element: T): boolean;
    	// (undocumented)
    setDynamicHeight?(element: T, height: number): void;
}

// @public (undocumented)
interface IMouseWheelEvent extends MouseEvent {
    	// (undocumented)
    readonly deltaMode: number;
    	// (undocumented)
    readonly deltaX: number;
    	// (undocumented)
    readonly deltaY: number;
    	// (undocumented)
    readonly deltaZ: number;
    	// (undocumented)
    readonly wheelDelta: number;
    	// (undocumented)
    readonly wheelDeltaX: number;
    	// (undocumented)
    readonly wheelDeltaY: number;
}

// @public (undocumented)
interface IObservable<T, _TChange = void> {
    	addObserver(observer: IObserver): void;
    	// (undocumented)
    readonly debugName: string;
    	get(): T;
    	// (undocumented)
    map<TNew>(fn: (value: T) => TNew): IObservable<TNew>;
    	read(reader: IReader): T;
    	// (undocumented)
    removeObserver(observer: IObserver): void;
    	// (undocumented)
    readonly TChange: _TChange;
}

// @public @deprecated (undocumented)
interface IObservableValue<T> {
    	// (undocumented)
    onDidChange: Event_2<T>;
    	// (undocumented)
    readonly value: T;
}

// @public (undocumented)
interface IObserver {
    	beginUpdate<T>(observable: IObservable<T>): void;
    	endUpdate<T>(observable: IObservable<T>): void;
    	handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;
}

// @public (undocumented)
interface IReader {
    	subscribeTo<T>(observable: IObservable<T, any>): void;
}

// @public (undocumented)
interface ISpliceable<T> {
    	// (undocumented)
    splice(start: number, deleteCount: number, toInsert: readonly T[]): void;
}

// @public (undocumented)
const enum ListDragOverEffect {
    	// (undocumented)
    Copy = 0,
    	// (undocumented)
    Move = 1,
}

// @public
export class ListView<T> implements ISpliceable<T>, IDisposable {
    	constructor(
    		container: HTMLElement,
    		virtualDelegate: IListVirtualDelegate<T>,
    		renderers: IListRenderer<any, any>[],
    		options?: IListViewOptions<T>,
    	);
    	// (undocumented)
    get containerDomNode(): HTMLElement;
    	// (undocumented)
    get contentHeight(): number;
    	// (undocumented)
    delegateScrollFromMouseWheelEvent(browserEvent: IMouseWheelEvent): void;
    	// (undocumented)
    delegateVerticalScrollbarPointerDown(browserEvent: PointerEvent): void;
    	// (undocumented)
    dispose(): void;
    	// (undocumented)
    domElement(index: number): HTMLElement | null;
    	// (undocumented)
    readonly domId: string;
    	// (undocumented)
    readonly domNode: HTMLElement;
    	// (undocumented)
    element(index: number): T;
    	// (undocumented)
    elementHeight(index: number): number;
    	// (undocumented)
    elementTop(index: number): number;
    	// (undocumented)
    get firstVisibleIndex(): number;
    	// (undocumented)
    getElementDomId(index: number): string;
    	// (undocumented)
    getScrollLeft(): number;
    	// (undocumented)
    getScrollTop(): number;
    	// (undocumented)
    indexAfter(position: number): number;
    	// (undocumented)
    indexAt(position: number): number;
    	// (undocumented)
    indexOf(element: T): number;
    	// (undocumented)
    get lastVisibleIndex(): number;
    	// (undocumented)
    layout(height?: number, width?: number): void;
    	// (undocumented)
    get length(): number;
    	// (undocumented)
    get onContextMenu(): Event_2<IListMouseEvent<T> | IListGestureEvent<T>>;
    	// (undocumented)
    readonly onDidChangeContentHeight: Event_2<number>;
    	// (undocumented)
    get onDidScroll(): Event_2<ScrollEvent>;
    	// (undocumented)
    get onMouseClick(): Event_2<IListMouseEvent<T>>;
    	// (undocumented)
    get onMouseDblClick(): Event_2<IListMouseEvent<T>>;
    	// (undocumented)
    get onMouseDown(): Event_2<IListMouseEvent<T>>;
    	// (undocumented)
    get onMouseMiddleClick(): Event_2<IListMouseEvent<T>>;
    	// (undocumented)
    get onMouseMove(): Event_2<IListMouseEvent<T>>;
    	// (undocumented)
    get onMouseOut(): Event_2<IListMouseEvent<T>>;
    	// (undocumented)
    get onMouseOver(): Event_2<IListMouseEvent<T>>;
    	// (undocumented)
    get onMouseUp(): Event_2<IListMouseEvent<T>>;
    	// (undocumented)
    get onTap(): Event_2<IListGestureEvent<T>>;
    	// (undocumented)
    get onTouchStart(): Event_2<IListTouchEvent<T>>;
    	// (undocumented)
    get onWillScroll(): Event_2<ScrollEvent>;
    	// (undocumented)
    get renderHeight(): number;
    	// (undocumented)
    rerender(): void;
    	// (undocumented)
    get scrollableElementDomNode(): HTMLElement;
    	// (undocumented)
    get scrollHeight(): number;
    	// (undocumented)
    get scrollTop(): number;
    	set scrollTop(scrollTop: number);
    	// (undocumented)
    setScrollLeft(scrollLeft: number): void;
    	// (undocumented)
    setScrollTop(scrollTop: number, reuseAnimation?: boolean): void;
    	// (undocumented)
    splice(start: number, deleteCount: number, elements?: readonly T[]): T[];
    	// (undocumented)
    updateElementHeight(index: number, size: number | undefined, anchorIndex: number | null): void;
    	// (undocumented)
    updateOptions(options: IListViewOptionsUpdate): void;
    	// (undocumented)
    updateWidth(index: number): void;
    	}

// @public (undocumented)
export class NativeDragAndDropData implements IDragAndDropData {
    	constructor();
    	// (undocumented)
    readonly files: any[];
    	// (undocumented)
    getData(): any;
    	// (undocumented)
    readonly types: any[];
    	// (undocumented)
    update(dataTransfer: DataTransfer): void;
}

// @public (undocumented)
const enum ScrollbarVisibility {
    	// (undocumented)
    Auto = 1,
    	// (undocumented)
    Hidden = 2,
    	// (undocumented)
    Visible = 3,
}

// @public (undocumented)
interface ScrollEvent {
    	// (undocumented)
    height: number;
    	// (undocumented)
    heightChanged: boolean;
    	// (undocumented)
    inSmoothScrolling: boolean;
    	// (undocumented)
    oldHeight: number;
    	// (undocumented)
    oldScrollHeight: number;
    	// (undocumented)
    oldScrollLeft: number;
    	// (undocumented)
    oldScrollTop: number;
    	// (undocumented)
    oldScrollWidth: number;
    	// (undocumented)
    oldWidth: number;
    	// (undocumented)
    scrollHeight: number;
    	// (undocumented)
    scrollHeightChanged: boolean;
    	// (undocumented)
    scrollLeft: number;
    	// (undocumented)
    scrollLeftChanged: boolean;
    	// (undocumented)
    scrollTop: number;
    	// (undocumented)
    scrollTopChanged: boolean;
    	// (undocumented)
    scrollWidth: number;
    	// (undocumented)
    scrollWidthChanged: boolean;
    	// (undocumented)
    width: number;
    	// (undocumented)
    widthChanged: boolean;
}

// (No @packageDocumentation comment for this package)

```
