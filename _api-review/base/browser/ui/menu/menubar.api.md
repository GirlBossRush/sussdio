## API Report File for "@sussudio/base/browser/ui/menu/menubar"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
class Color {
    	constructor(arg: RGBA | HSLA | HSVA);
    	// (undocumented)
    static readonly black: Color;
    	// (undocumented)
    blend(c: Color): Color;
    	// (undocumented)
    static readonly blue: Color;
    	// (undocumented)
    static readonly cyan: Color;
    	// (undocumented)
    darken(factor: number): Color;
    	// (undocumented)
    static equals(a: Color | null, b: Color | null): boolean;
    	// (undocumented)
    equals(other: Color | null): boolean;
    	// (undocumented)
    flatten(...backgrounds: Color[]): Color;
    	// (undocumented)
    static fromHex(hex: string): Color;
    	getContrastRatio(another: Color): number;
    	// (undocumented)
    static getDarkerColor(of: Color, relative: Color, factor?: number): Color;
    	// (undocumented)
    static getLighterColor(of: Color, relative: Color, factor?: number): Color;
    	getRelativeLuminance(): number;
    	// (undocumented)
    static readonly green: Color;
    	// (undocumented)
    get hsla(): HSLA;
    	// (undocumented)
    get hsva(): HSVA;
    	isDarker(): boolean;
    	// (undocumented)
    isDarkerThan(another: Color): boolean;
    	isLighter(): boolean;
    	// (undocumented)
    isLighterThan(another: Color): boolean;
    	// (undocumented)
    isOpaque(): boolean;
    	// (undocumented)
    isTransparent(): boolean;
    	// (undocumented)
    lighten(factor: number): Color;
    	// (undocumented)
    static readonly lightgrey: Color;
    	// (undocumented)
    makeOpaque(opaqueBackground: Color): Color;
    	// (undocumented)
    opposite(): Color;
    	// (undocumented)
    static readonly red: Color;
    	// (undocumented)
    readonly rgba: RGBA;
    	// (undocumented)
    toString(): string;
    	// (undocumented)
    transparent(factor: number): Color;
    	// (undocumented)
    static readonly transparent: Color;
    	// (undocumented)
    static readonly white: Color;
}

// @public (undocumented)
namespace Color {
    	// (undocumented)
    namespace Format {
        		// (undocumented)
        namespace CSS {
            			function format(color: Color): string;
            			function formatHex(color: Color): string;
            			function formatHexA(color: Color, compact?: boolean): string;
            			// (undocumented)
            function formatHSL(color: Color): string;
            			// (undocumented)
            function formatHSLA(color: Color): string;
            			// (undocumented)
            function formatRGB(color: Color): string;
            			// (undocumented)
            function formatRGBA(color: Color): string;
            			function parseHex(hex: string): Color | null;
            		}
        	}
}

// @public (undocumented)
enum Direction {
    	// (undocumented)
    Left = 1,
    	// (undocumented)
    Right = 0,
}

// @public
abstract class Disposable implements IDisposable {
    	constructor();
    	// (undocumented)
    dispose(): void;
    	static readonly None: Readonly<IDisposable>;
    	protected _register<T extends IDisposable>(o: T): T;
    	// (undocumented)
    protected readonly _store: DisposableStore;
}

// @public
class DisposableStore implements IDisposable {
    	constructor();
    	add<T extends IDisposable>(o: T): T;
    	clear(): void;
    	// (undocumented)
    static DISABLE_DISPOSED_WARNING: boolean;
    	dispose(): void;
    	// (undocumented)
    get isDisposed(): boolean;
    	}

// @public
interface Event_2<T> {
    	// (undocumented)
    (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
}

// @public (undocumented)
namespace Event_2 {
    	const // (undocumented)
    None: Event_2<any>;
    	function accumulate<T>(event: Event_2<T>, delay?: number, disposable?: DisposableStore): Event_2<T[]>;
    	function any<T>(...events: Event_2<T>[]): Event_2<T>;
    	// (undocumented)
    function any(...events: Event_2<any>[]): Event_2<void>;
    	function buffer<T>(event: Event_2<T>, flushAfterTimeout?: boolean, _buffer?: T[]): Event_2<T>;
    	// (undocumented)
    function chain<T>(event: Event_2<T>): IChainableEvent<T>;
    	function debounce<T>(
    		event: Event_2<T>,
    		merge: (last: T | undefined, event: T) => T,
    		delay?: number,
    		leading?: boolean,
    		leakWarningThreshold?: number,
    		disposable?: DisposableStore,
    	): Event_2<T>;
    	function debounce<I, O>(
    		event: Event_2<I>,
    		merge: (last: O | undefined, event: I) => O,
    		delay?: number,
    		leading?: boolean,
    		leakWarningThreshold?: number,
    		disposable?: DisposableStore,
    	): Event_2<O>;
    	function defer(event: Event_2<unknown>, disposable?: DisposableStore): Event_2<void>;
    	// (undocumented)
    interface DOMEventEmitter {
        		// (undocumented)
        addEventListener(event: string | symbol, listener: Function): void;
        		// (undocumented)
        removeEventListener(event: string | symbol, listener: Function): void;
        	}
    	function filter<T, U>(event: Event_2<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event_2<T>;
    	// (undocumented)
    function filter<T>(event: Event_2<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event_2<T>;
    	// (undocumented)
    function filter<T, R>(event: Event_2<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event_2<R>;
    	function forEach<I>(event: Event_2<I>, each: (i: I) => void, disposable?: DisposableStore): Event_2<I>;
    	// (undocumented)
    function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map?: (...args: any[]) => T): Event_2<T>;
    	// (undocumented)
    function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map?: (...args: any[]) => T): Event_2<T>;
    	// (undocumented)
    function fromObservable<T>(obs: IObservable<T, any>, store?: DisposableStore): Event_2<T>;
    	// (undocumented)
    interface IChainableEvent<T> extends IDisposable {
        		// (undocumented)
        debounce(
        			merge: (last: T | undefined, event: T) => T,
        			delay?: number,
        			leading?: boolean,
        			leakWarningThreshold?: number,
        		): IChainableEvent<T>;
        		// (undocumented)
        debounce<R>(
        			merge: (last: R | undefined, event: T) => R,
        			delay?: number,
        			leading?: boolean,
        			leakWarningThreshold?: number,
        		): IChainableEvent<R>;
        		// (undocumented)
        event: Event_2<T>;
        		// (undocumented)
        filter(fn: (e: T) => boolean): IChainableEvent<T>;
        		// (undocumented)
        filter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;
        		// (undocumented)
        forEach(fn: (i: T) => void): IChainableEvent<T>;
        		// (undocumented)
        latch(): IChainableEvent<T>;
        		// (undocumented)
        map<O>(fn: (i: T) => O): IChainableEvent<O>;
        		// (undocumented)
        on(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
        		// (undocumented)
        once(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;
        		// (undocumented)
        reduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;
        	}
    	function latch<T>(event: Event_2<T>, equals?: (a: T, b: T) => boolean, disposable?: DisposableStore): Event_2<T>;
    	function map<I, O>(event: Event_2<I>, map: (i: I) => O, disposable?: DisposableStore): Event_2<O>;
    	// (undocumented)
    interface NodeEventEmitter {
        		// (undocumented)
        on(event: string | symbol, listener: Function): unknown;
        		// (undocumented)
        removeListener(event: string | symbol, listener: Function): unknown;
        	}
    	function once<T>(event: Event_2<T>): Event_2<T>;
    	function reduce<I, O>(
    		event: Event_2<I>,
    		merge: (last: O | undefined, event: I) => O,
    		initial?: O,
    		disposable?: DisposableStore,
    	): Event_2<O>;
    	// (undocumented)
    function runAndSubscribe<T>(event: Event_2<T>, handler: (e: T | undefined) => any): IDisposable;
    	// (undocumented)
    function runAndSubscribeWithStore<T>(
    		event: Event_2<T>,
    		handler: (e: T | undefined, disposableStore: DisposableStore) => any,
    	): IDisposable;
    	function signal<T>(event: Event_2<T>): Event_2<void>;
    	function split<T, U>(
    		event: Event_2<T | U>,
    		isT: (e: T | U) => e is T,
    		disposable?: DisposableStore,
    	): [Event_2<T>, Event_2<U>];
    	// (undocumented)
    function toPromise<T>(event: Event_2<T>): Promise<T>;
}

// @public (undocumented)
class HSLA {
    	constructor(h: number, s: number, l: number, a: number);
    	readonly a: number;
    	// (undocumented)
    static equals(a: HSLA, b: HSLA): boolean;
    	static fromRGBA(rgba: RGBA): HSLA;
    	readonly h: number;
    	// (undocumented)
    _hslaBrand: void;
    	readonly l: number;
    	readonly s: number;
    	static toRGBA(hsla: HSLA): RGBA;
}

// @public (undocumented)
class HSVA {
    	constructor(h: number, s: number, v: number, a: number);
    	readonly a: number;
    	// (undocumented)
    static equals(a: HSVA, b: HSVA): boolean;
    	// (undocumented)
    static fromRGBA(rgba: RGBA): HSVA;
    	readonly h: number;
    	// (undocumented)
    _hsvaBrand: void;
    	readonly s: number;
    	// (undocumented)
    static toRGBA(hsva: HSVA): RGBA;
    	readonly v: number;
}

// @public (undocumented)
interface IAction {
    	// (undocumented)
    checked?: boolean;
    	// (undocumented)
    class: string | undefined;
    	// (undocumented)
    enabled: boolean;
    	// (undocumented)
    readonly id: string;
    	// (undocumented)
    label: string;
    	// (undocumented)
    run(event?: unknown): unknown;
    	// (undocumented)
    tooltip: string;
}

// @public (undocumented)
interface IActionRunner extends IDisposable {
    	// (undocumented)
    readonly onDidRun: Event_2<IRunEvent>;
    	// (undocumented)
    readonly onWillRun: Event_2<IRunEvent>;
    	// (undocumented)
    run(action: IAction, context?: unknown): unknown;
}

// @public
interface IDisposable {
    	// (undocumented)
    dispose(): void;
}

// @public (undocumented)
export interface IMenuBarOptions {
    	// (undocumented)
    actionRunner?: IActionRunner;
    	// (undocumented)
    alwaysOnMnemonics?: boolean;
    	// (undocumented)
    compactMode?: Direction;
    	// (undocumented)
    disableAltFocus?: boolean;
    	// (undocumented)
    enableMnemonics?: boolean;
    	// (undocumented)
    getCompactMenuActions?: () => IAction[];
    	// (undocumented)
    getKeybinding?: (action: IAction) => ResolvedKeybinding | undefined;
    	// (undocumented)
    visibility?: string;
}

// @public (undocumented)
interface IMenuStyles {
    	// (undocumented)
    backgroundColor?: Color;
    	// (undocumented)
    borderColor?: Color;
    	// (undocumented)
    foregroundColor?: Color;
    	// (undocumented)
    scrollbarShadow?: Color;
    	// (undocumented)
    scrollbarSliderActiveBackground?: Color;
    	// (undocumented)
    scrollbarSliderBackground?: Color;
    	// (undocumented)
    scrollbarSliderHoverBackground?: Color;
    	// (undocumented)
    selectionBackgroundColor?: Color;
    	// (undocumented)
    selectionBorderColor?: Color;
    	// (undocumented)
    selectionForegroundColor?: Color;
    	// (undocumented)
    separatorColor?: Color;
    	// (undocumented)
    shadowColor?: Color;
}

// @public (undocumented)
interface IObservable<T, _TChange = void> {
    	addObserver(observer: IObserver): void;
    	// (undocumented)
    readonly debugName: string;
    	get(): T;
    	// (undocumented)
    map<TNew>(fn: (value: T) => TNew): IObservable<TNew>;
    	read(reader: IReader): T;
    	// (undocumented)
    removeObserver(observer: IObserver): void;
    	// (undocumented)
    readonly TChange: _TChange;
}

// @public (undocumented)
interface IObserver {
    	beginUpdate<T>(observable: IObservable<T>): void;
    	endUpdate<T>(observable: IObservable<T>): void;
    	handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;
}

// @public (undocumented)
interface IReader {
    	subscribeTo<T>(observable: IObservable<T, any>): void;
}

// @public (undocumented)
interface IRunEvent {
    	// (undocumented)
    readonly action: IAction;
    	// (undocumented)
    readonly error?: Error;
}

// @public (undocumented)
export class MenuBar extends Disposable {
    	constructor(container: HTMLElement, options?: IMenuBarOptions);
    	// (undocumented)
    blur(): void;
    	// (undocumented)
    createOverflowMenu(): void;
    	// (undocumented)
    dispose(): void;
    	// (undocumented)
    getHeight(): number;
    	// (undocumented)
    getWidth(): number;
    	// (undocumented)
    get isVisible(): boolean;
    	// (undocumented)
    get onFocusStateChange(): Event_2<boolean>;
    	// (undocumented)
    get onVisibilityChange(): Event_2<boolean>;
    	// (undocumented)
    static readonly OVERFLOW_INDEX: number;
    	// (undocumented)
    push(arg: MenuBarMenu | MenuBarMenu[]): void;
    	// (undocumented)
    style(style: IMenuStyles): void;
    	// (undocumented)
    toggleFocus(): void;
    	// (undocumented)
    update(options?: IMenuBarOptions): void;
    	// (undocumented)
    updateMenu(menu: MenuBarMenu): void;
    	}

// @public (undocumented)
export interface MenuBarMenu {
    	// (undocumented)
    actions: IAction[];
    	// (undocumented)
    label: string;
}

// @public (undocumented)
class ResolvedChord {
    	constructor(
    		ctrlKey: boolean,
    		shiftKey: boolean,
    		altKey: boolean,
    		metaKey: boolean,
    		keyLabel: string | null,
    		keyAriaLabel: string | null,
    	);
    	// (undocumented)
    readonly altKey: boolean;
    	// (undocumented)
    readonly ctrlKey: boolean;
    	// (undocumented)
    readonly keyAriaLabel: string | null;
    	// (undocumented)
    readonly keyLabel: string | null;
    	// (undocumented)
    readonly metaKey: boolean;
    	// (undocumented)
    readonly shiftKey: boolean;
}

// @public
abstract class ResolvedKeybinding {
    	abstract getAriaLabel(): string | null;
    	abstract getChords(): ResolvedChord[];
    	abstract getDispatchChords(): (string | null)[];
    	abstract getElectronAccelerator(): string | null;
    	abstract getLabel(): string | null;
    	abstract getSingleModifierDispatchChords(): (SingleModifierChord | null)[];
    	abstract getUserSettingsLabel(): string | null;
    	abstract hasMultipleChords(): boolean;
    	abstract isWYSIWYG(): boolean;
}

// @public (undocumented)
class RGBA {
    	constructor(r: number, g: number, b: number, a?: number);
    	readonly a: number;
    	readonly b: number;
    	// (undocumented)
    static equals(a: RGBA, b: RGBA): boolean;
    	readonly g: number;
    	readonly r: number;
    	// (undocumented)
    _rgbaBrand: void;
}

// @public (undocumented)
type SingleModifierChord = 'ctrl' | 'shift' | 'alt' | 'meta';

// (No @packageDocumentation comment for this package)

```
