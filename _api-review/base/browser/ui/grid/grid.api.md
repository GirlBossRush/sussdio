## API Report File for "@sussudio/base/browser/ui/grid/grid"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
interface Box {
    	// (undocumented)
    readonly height: number;
    	// (undocumented)
    readonly left: number;
    	// (undocumented)
    readonly top: number;
    	// (undocumented)
    readonly width: number;
}

// @public (undocumented)
class BranchNode implements IView_3<ILayoutContext>, IDisposable {
    	constructor(
    		orientation: Orientation,
    		layoutController: LayoutController,
    		styles: IGridViewStyles,
    		splitviewProportionalLayout: boolean,
    		size?: number,
    		orthogonalSize?: number,
    		edgeSnapping?: boolean,
    		childDescriptors?: INodeDescriptor[],
    	);
    	// (undocumented)
    get absoluteOffset(): number;
    	// (undocumented)
    get absoluteOrthogonalOffset(): number;
    	// (undocumented)
    addChild(node: Node_2, size: number | Sizing_2, index: number, skipLayout?: boolean): void;
    	// (undocumented)
    get boundarySashes(): IRelativeBoundarySashes;
    	set boundarySashes(boundarySashes: IRelativeBoundarySashes);
    	// (undocumented)
    readonly children: Node_2[];
    	// (undocumented)
    dispose(): void;
    	// (undocumented)
    distributeViewSizes(recursive?: boolean): void;
    	// (undocumented)
    get edgeSnapping(): boolean;
    	set edgeSnapping(edgeSnapping: boolean);
    	// (undocumented)
    readonly element: HTMLElement;
    	// (undocumented)
    getChildCachedVisibleSize(index: number): number | undefined;
    	// (undocumented)
    getChildSize(index: number): number;
    	// (undocumented)
    get height(): number;
    	// (undocumented)
    isChildSizeMaximized(index: number): boolean;
    	// (undocumented)
    isChildVisible(index: number): boolean;
    	// (undocumented)
    layout(size: number, offset: number, ctx: ILayoutContext | undefined): void;
    	// (undocumented)
    readonly layoutController: LayoutController;
    	// (undocumented)
    get left(): number;
    	// (undocumented)
    get maximumHeight(): number;
    	// (undocumented)
    get maximumOrthogonalSize(): number;
    	// (undocumented)
    get maximumSize(): number;
    	// (undocumented)
    get maximumWidth(): number;
    	// (undocumented)
    get minimumHeight(): number;
    	// (undocumented)
    get minimumOrthogonalSize(): number;
    	// (undocumented)
    get minimumSize(): number;
    	// (undocumented)
    get minimumWidth(): number;
    	// (undocumented)
    moveChild(from: number, to: number): void;
    	// (undocumented)
    readonly onDidChange: Event_2<number | undefined>;
    	// (undocumented)
    readonly onDidSashReset: Event_2<GridLocation>;
    	// (undocumented)
    readonly onDidScroll: Event_2<void>;
    	// (undocumented)
    readonly orientation: Orientation;
    	// (undocumented)
    get orthogonalSize(): number;
    	// (undocumented)
    get priority(): LayoutPriority;
    	// (undocumented)
    get proportionalLayout(): boolean;
    	// (undocumented)
    removeChild(index: number, sizing?: Sizing_2): void;
    	// (undocumented)
    resizeChild(index: number, size: number): void;
    	// (undocumented)
    setChildVisible(index: number, visible: boolean): void;
    	// (undocumented)
    setVisible(visible: boolean): void;
    	// (undocumented)
    get size(): number;
    	// (undocumented)
    readonly splitviewProportionalLayout: boolean;
    	// (undocumented)
    style(styles: IGridViewStyles): void;
    	// (undocumented)
    get styles(): IGridViewStyles;
    	// (undocumented)
    swapChildren(from: number, to: number): void;
    	// (undocumented)
    get top(): number;
    	// (undocumented)
    trySet2x2(other: BranchNode): IDisposable;
    	// (undocumented)
    get width(): number;
}

// @public (undocumented)
class Color {
    	constructor(arg: RGBA | HSLA | HSVA);
    	// (undocumented)
    static readonly black: Color;
    	// (undocumented)
    blend(c: Color): Color;
    	// (undocumented)
    static readonly blue: Color;
    	// (undocumented)
    static readonly cyan: Color;
    	// (undocumented)
    darken(factor: number): Color;
    	// (undocumented)
    static equals(a: Color | null, b: Color | null): boolean;
    	// (undocumented)
    equals(other: Color | null): boolean;
    	// (undocumented)
    flatten(...backgrounds: Color[]): Color;
    	// (undocumented)
    static fromHex(hex: string): Color;
    	getContrastRatio(another: Color): number;
    	// (undocumented)
    static getDarkerColor(of: Color, relative: Color, factor?: number): Color;
    	// (undocumented)
    static getLighterColor(of: Color, relative: Color, factor?: number): Color;
    	getRelativeLuminance(): number;
    	// (undocumented)
    static readonly green: Color;
    	// (undocumented)
    get hsla(): HSLA;
    	// (undocumented)
    get hsva(): HSVA;
    	isDarker(): boolean;
    	// (undocumented)
    isDarkerThan(another: Color): boolean;
    	isLighter(): boolean;
    	// (undocumented)
    isLighterThan(another: Color): boolean;
    	// (undocumented)
    isOpaque(): boolean;
    	// (undocumented)
    isTransparent(): boolean;
    	// (undocumented)
    lighten(factor: number): Color;
    	// (undocumented)
    static readonly lightgrey: Color;
    	// (undocumented)
    makeOpaque(opaqueBackground: Color): Color;
    	// (undocumented)
    opposite(): Color;
    	// (undocumented)
    static readonly red: Color;
    	// (undocumented)
    readonly rgba: RGBA;
    	// (undocumented)
    toString(): string;
    	// (undocumented)
    transparent(factor: number): Color;
    	// (undocumented)
    static readonly transparent: Color;
    	// (undocumented)
    static readonly white: Color;
}

// @public (undocumented)
namespace Color {
    	// (undocumented)
    namespace Format {
        		// (undocumented)
        namespace CSS {
            			function format(color: Color): string;
            			function formatHex(color: Color): string;
            			function formatHexA(color: Color, compact?: boolean): string;
            			// (undocumented)
            function formatHSL(color: Color): string;
            			// (undocumented)
            function formatHSLA(color: Color): string;
            			// (undocumented)
            function formatRGB(color: Color): string;
            			// (undocumented)
            function formatRGBA(color: Color): string;
            			function parseHex(hex: string): Color | null;
            		}
        	}
}

// @public
export function createSerializedGrid<T>(gridDescriptor: GridDescriptor<T>): ISerializedGrid;

// @public (undocumented)
export const enum Direction {
    	// (undocumented)
    Down = 1,
    	// (undocumented)
    Left = 2,
    	// (undocumented)
    Right = 3,
    	// (undocumented)
    Up = 0,
}

// @public
abstract class Disposable implements IDisposable {
    	constructor();
    	// (undocumented)
    dispose(): void;
    	static readonly None: Readonly<IDisposable>;
    	protected _register<T extends IDisposable>(o: T): T;
    	// (undocumented)
    protected readonly _store: DisposableStore;
}

// @public
class DisposableStore implements IDisposable {
    	constructor();
    	add<T extends IDisposable>(o: T): T;
    	clear(): void;
    	// (undocumented)
    static DISABLE_DISPOSED_WARNING: boolean;
    	dispose(): void;
    	// (undocumented)
    get isDisposed(): boolean;
    	}

// @public (undocumented)
export type DistributeSizing = {
    	type: 'distribute';
};

// @public
type DistributeSizing_2 = {
    	type: 'distribute';
};

// @public
interface Event_2<T> {
    	// (undocumented)
    (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
}

// @public (undocumented)
namespace Event_2 {
    	const // (undocumented)
    None: Event_2<any>;
    	function accumulate<T>(event: Event_2<T>, delay?: number, disposable?: DisposableStore): Event_2<T[]>;
    	function any<T>(...events: Event_2<T>[]): Event_2<T>;
    	// (undocumented)
    function any(...events: Event_2<any>[]): Event_2<void>;
    	function buffer<T>(event: Event_2<T>, flushAfterTimeout?: boolean, _buffer?: T[]): Event_2<T>;
    	// (undocumented)
    function chain<T>(event: Event_2<T>): IChainableEvent<T>;
    	function debounce<T>(
    		event: Event_2<T>,
    		merge: (last: T | undefined, event: T) => T,
    		delay?: number,
    		leading?: boolean,
    		leakWarningThreshold?: number,
    		disposable?: DisposableStore,
    	): Event_2<T>;
    	function debounce<I, O>(
    		event: Event_2<I>,
    		merge: (last: O | undefined, event: I) => O,
    		delay?: number,
    		leading?: boolean,
    		leakWarningThreshold?: number,
    		disposable?: DisposableStore,
    	): Event_2<O>;
    	function defer(event: Event_2<unknown>, disposable?: DisposableStore): Event_2<void>;
    	// (undocumented)
    interface DOMEventEmitter {
        		// (undocumented)
        addEventListener(event: string | symbol, listener: Function): void;
        		// (undocumented)
        removeEventListener(event: string | symbol, listener: Function): void;
        	}
    	function filter<T, U>(event: Event_2<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event_2<T>;
    	// (undocumented)
    function filter<T>(event: Event_2<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event_2<T>;
    	// (undocumented)
    function filter<T, R>(event: Event_2<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event_2<R>;
    	function forEach<I>(event: Event_2<I>, each: (i: I) => void, disposable?: DisposableStore): Event_2<I>;
    	// (undocumented)
    function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map?: (...args: any[]) => T): Event_2<T>;
    	// (undocumented)
    function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map?: (...args: any[]) => T): Event_2<T>;
    	// (undocumented)
    function fromObservable<T>(obs: IObservable<T, any>, store?: DisposableStore): Event_2<T>;
    	// (undocumented)
    interface IChainableEvent<T> extends IDisposable {
        		// (undocumented)
        debounce(
        			merge: (last: T | undefined, event: T) => T,
        			delay?: number,
        			leading?: boolean,
        			leakWarningThreshold?: number,
        		): IChainableEvent<T>;
        		// (undocumented)
        debounce<R>(
        			merge: (last: R | undefined, event: T) => R,
        			delay?: number,
        			leading?: boolean,
        			leakWarningThreshold?: number,
        		): IChainableEvent<R>;
        		// (undocumented)
        event: Event_2<T>;
        		// (undocumented)
        filter(fn: (e: T) => boolean): IChainableEvent<T>;
        		// (undocumented)
        filter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;
        		// (undocumented)
        forEach(fn: (i: T) => void): IChainableEvent<T>;
        		// (undocumented)
        latch(): IChainableEvent<T>;
        		// (undocumented)
        map<O>(fn: (i: T) => O): IChainableEvent<O>;
        		// (undocumented)
        on(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
        		// (undocumented)
        once(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;
        		// (undocumented)
        reduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;
        	}
    	function latch<T>(event: Event_2<T>, equals?: (a: T, b: T) => boolean, disposable?: DisposableStore): Event_2<T>;
    	function map<I, O>(event: Event_2<I>, map: (i: I) => O, disposable?: DisposableStore): Event_2<O>;
    	// (undocumented)
    interface NodeEventEmitter {
        		// (undocumented)
        on(event: string | symbol, listener: Function): unknown;
        		// (undocumented)
        removeListener(event: string | symbol, listener: Function): unknown;
        	}
    	function once<T>(event: Event_2<T>): Event_2<T>;
    	function reduce<I, O>(
    		event: Event_2<I>,
    		merge: (last: O | undefined, event: I) => O,
    		initial?: O,
    		disposable?: DisposableStore,
    	): Event_2<O>;
    	// (undocumented)
    function runAndSubscribe<T>(event: Event_2<T>, handler: (e: T | undefined) => any): IDisposable;
    	// (undocumented)
    function runAndSubscribeWithStore<T>(
    		event: Event_2<T>,
    		handler: (e: T | undefined, disposableStore: DisposableStore) => any,
    	): IDisposable;
    	function signal<T>(event: Event_2<T>): Event_2<void>;
    	function split<T, U>(
    		event: Event_2<T | U>,
    		isT: (e: T | U) => e is T,
    		disposable?: DisposableStore,
    	): [Event_2<T>, Event_2<U>];
    	// (undocumented)
    function toPromise<T>(event: Event_2<T>): Promise<T>;
}

// @public (undocumented)
export function getRelativeLocation(
	rootOrientation: Orientation,
	location: GridLocation,
	direction: Direction,
): GridLocation;

// @public
export class Grid<T extends IView = IView> extends Disposable {
    	constructor(view: T | GridView, options?: IGridOptions);
    	addView(newView: T, size: number | Sizing, referenceView: T, direction: Direction): void;
    	// (undocumented)
    protected _addView(newView: T, size: number | Sizing_2, location: GridLocation): void;
    	get boundarySashes(): IBoundarySashes;
    	set boundarySashes(boundarySashes: IBoundarySashes);
    	distributeViewSizes(): void;
    	set edgeSnapping(edgeSnapping: boolean);
    	get element(): HTMLElement;
    	getNeighborViews(view: T, direction: Direction, wrap?: boolean): T[];
    	getViewCachedVisibleSize(view: T): number | undefined;
    	getViews(): GridBranchNode<T>;
    	getViewSize(view?: T): IViewSize;
    	// (undocumented)
    protected gridview: GridView;
    	get height(): number;
    	isViewSizeMaximized(view: T): boolean;
    	isViewVisible(view: T): boolean;
    	layout(width: number, height: number, top?: number, left?: number): void;
    	maximizeViewSize(view: T): void;
    	get maximumHeight(): number;
    	get maximumWidth(): number;
    	get minimumHeight(): number;
    	get minimumWidth(): number;
    	moveView(view: T, sizing: number | Sizing, referenceView: T, direction: Direction): void;
    	moveViewTo(view: T, location: GridLocation): void;
    	readonly onDidChange: Event_2<
    		| {
        				width: number;
        				height: number;
        		  }
    		| undefined
    	>;
    	readonly onDidScroll: Event_2<void>;
    	get orientation(): Orientation;
    	set orientation(orientation: Orientation);
    	removeView(view: T, sizing?: Sizing): void;
    	resizeView(view: T, size: IViewSize): void;
    	setViewVisible(view: T, visible: boolean): void;
    	// (undocumented)
    style(styles: IGridStyles): void;
    	swapViews(from: T, to: T): void;
    	get width(): number;
}

// @public (undocumented)
export interface GridBranchNode<T extends IView> {
    	// (undocumented)
    readonly box: Box;
    	// (undocumented)
    readonly children: GridNode<T>[];
}

// @public (undocumented)
interface GridBranchNode_2 {
    	// (undocumented)
    readonly box: Box;
    	// (undocumented)
    readonly children: GridNode_2[];
}

// @public (undocumented)
export type GridBranchNodeDescriptor<T> = {
    	size?: number;
    	groups: GridNodeDescriptor<T>[];
};

// @public (undocumented)
export type GridDescriptor<T> = {
    	orientation: Orientation;
} & GridBranchNodeDescriptor<T>;

// @public (undocumented)
export interface GridLeafNode<T extends IView> {
    	// (undocumented)
    readonly box: Box;
    	// (undocumented)
    readonly cachedVisibleSize: number | undefined;
    	// (undocumented)
    readonly view: T;
}

// @public (undocumented)
interface GridLeafNode_2 {
    	// (undocumented)
    readonly box: Box;
    	// (undocumented)
    readonly cachedVisibleSize: number | undefined;
    	// (undocumented)
    readonly view: IView_2;
}

// @public (undocumented)
export type GridLeafNodeDescriptor<T> = {
    	size?: number;
    	data?: any;
};

// @public
type GridLocation = number[];

// @public (undocumented)
export type GridNode<T extends IView> = GridLeafNode<T> | GridBranchNode<T>;

// @public (undocumented)
type GridNode_2 = GridLeafNode_2 | GridBranchNode_2;

// @public (undocumented)
export type GridNodeDescriptor<T> = GridBranchNodeDescriptor<T> | GridLeafNodeDescriptor<T>;

// @public
class GridView implements IDisposable {
    	constructor(options?: IGridViewOptions);
    	addView(view: IView_2, size: number | Sizing_2, location: GridLocation): void;
    	// (undocumented)
    get boundarySashes(): IBoundarySashes;
    	set boundarySashes(boundarySashes: IBoundarySashes);
    	static deserialize<T extends ISerializableView_2>(
    		json: ISerializedGridView,
    		deserializer: IViewDeserializer_2<T>,
    		options?: IGridViewOptions,
    	): GridView;
    	// (undocumented)
    dispose(): void;
    	distributeViewSizes(location?: GridLocation): void;
    	set edgeSnapping(edgeSnapping: boolean);
    	readonly element: HTMLElement;
    	getView(): GridBranchNode_2;
    	getView(location: GridLocation): GridNode_2;
    	getViewCachedVisibleSize(location: GridLocation): number | undefined;
    	getViewMap(map: Map<IView_2, HTMLElement>, node?: Node_2): void;
    	getViewSize(location?: GridLocation): IViewSize;
    	get height(): number;
    	isViewSizeMaximized(location: GridLocation): boolean;
    	isViewVisible(location: GridLocation): boolean;
    	layout(width: number, height: number, top?: number, left?: number): void;
    	maximizeViewSize(location: GridLocation): void;
    	get maximumHeight(): number;
    	get maximumWidth(): number;
    	get minimumHeight(): number;
    	get minimumWidth(): number;
    	moveView(parentLocation: GridLocation, from: number, to: number): void;
    	readonly onDidChange: Event_2<IViewSize | undefined>;
    	readonly onDidSashReset: Event_2<GridLocation>;
    	readonly onDidScroll: Event_2<void>;
    	// (undocumented)
    get orientation(): Orientation;
    	set orientation(orientation: Orientation);
    	removeView(location: GridLocation, sizing?: DistributeSizing_2): IView_2;
    	resizeView(location: GridLocation, size: Partial<IViewSize>): void;
    	setViewVisible(location: GridLocation, visible: boolean): void;
    	// (undocumented)
    style(styles: IGridViewStyles): void;
    	swapViews(from: GridLocation, to: GridLocation): void;
    	trySet2x2(): void;
    	get width(): number;
}

// @public (undocumented)
class HSLA {
    	constructor(h: number, s: number, l: number, a: number);
    	readonly a: number;
    	// (undocumented)
    static equals(a: HSLA, b: HSLA): boolean;
    	static fromRGBA(rgba: RGBA): HSLA;
    	readonly h: number;
    	// (undocumented)
    _hslaBrand: void;
    	readonly l: number;
    	readonly s: number;
    	static toRGBA(hsla: HSLA): RGBA;
}

// @public (undocumented)
class HSVA {
    	constructor(h: number, s: number, v: number, a: number);
    	readonly a: number;
    	// (undocumented)
    static equals(a: HSVA, b: HSVA): boolean;
    	// (undocumented)
    static fromRGBA(rgba: RGBA): HSVA;
    	readonly h: number;
    	// (undocumented)
    _hsvaBrand: void;
    	readonly s: number;
    	// (undocumented)
    static toRGBA(hsva: HSVA): RGBA;
    	readonly v: number;
}

// @public (undocumented)
interface IBoundarySashes {
    	// (undocumented)
    readonly bottom?: Sash;
    	// (undocumented)
    readonly left?: Sash;
    	// (undocumented)
    readonly right?: Sash;
    	// (undocumented)
    readonly top?: Sash;
}

// @public
interface IDisposable {
    	// (undocumented)
    dispose(): void;
}

// @public (undocumented)
export interface IGridOptions extends IGridViewOptions {}

// @public (undocumented)
export interface IGridStyles extends IGridViewStyles {}

// @public (undocumented)
interface IGridViewOptions {
    	readonly proportionalLayout?: boolean;
    	readonly styles?: IGridViewStyles;
}

// @public (undocumented)
interface IGridViewStyles extends ISplitViewStyles {}

// @public
interface IHorizontalSashLayoutProvider {
    	// (undocumented)
    getHorizontalSashLeft?(sash: Sash): number;
    	// (undocumented)
    getHorizontalSashTop(sash: Sash): number;
    	// (undocumented)
    getHorizontalSashWidth?(sash: Sash): number;
}

// @public (undocumented)
interface IHorizontalSashOptions extends ISashOptions {
    	// (undocumented)
    readonly orientation: Orientation.HORIZONTAL;
}

// @public (undocumented)
interface ILayoutContext {
    	// (undocumented)
    readonly absoluteOffset: number;
    	// (undocumented)
    readonly absoluteOrthogonalOffset: number;
    	// (undocumented)
    readonly absoluteOrthogonalSize: number;
    	// (undocumented)
    readonly absoluteSize: number;
    	// (undocumented)
    readonly orthogonalSize: number;
}

// @public (undocumented)
interface INodeDescriptor {
    	// (undocumented)
    node: Node_2;
    	// (undocumented)
    visible?: boolean;
}

// @public (undocumented)
export type InvisibleSizing = {
    	type: 'invisible';
    	cachedVisibleSize: number;
};

// @public
type InvisibleSizing_2 = {
    	type: 'invisible';
    	cachedVisibleSize: number;
};

// @public (undocumented)
interface IObservable<T, _TChange = void> {
    	addObserver(observer: IObserver): void;
    	// (undocumented)
    readonly debugName: string;
    	get(): T;
    	// (undocumented)
    map<TNew>(fn: (value: T) => TNew): IObservable<TNew>;
    	read(reader: IReader): T;
    	// (undocumented)
    removeObserver(observer: IObserver): void;
    	// (undocumented)
    readonly TChange: _TChange;
}

// @public (undocumented)
interface IObserver {
    	beginUpdate<T>(observable: IObservable<T>): void;
    	endUpdate<T>(observable: IObservable<T>): void;
    	handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;
}

// @public (undocumented)
interface IReader {
    	subscribeTo<T>(observable: IObservable<T, any>): void;
}

// @public (undocumented)
interface IRelativeBoundarySashes {
    	// (undocumented)
    readonly end?: Sash;
    	// (undocumented)
    readonly orthogonalEnd?: Sash;
    	// (undocumented)
    readonly orthogonalStart?: Sash;
    	// (undocumented)
    readonly start?: Sash;
}

// @public (undocumented)
interface ISashEvent {
    	// (undocumented)
    readonly altKey: boolean;
    	// (undocumented)
    readonly currentX: number;
    	// (undocumented)
    readonly currentY: number;
    	// (undocumented)
    readonly startX: number;
    	// (undocumented)
    readonly startY: number;
}

// @public (undocumented)
interface ISashOptions {
    	readonly orientation: Orientation;
    	readonly orthogonalEdge?: OrthogonalEdge;
    	readonly orthogonalEndSash?: Sash;
    	readonly orthogonalStartSash?: Sash;
    	readonly size?: number;
}

// @public (undocumented)
export interface ISerializableView extends IView {
    	// (undocumented)
    toJSON(): object;
}

// @public (undocumented)
interface ISerializableView_2 extends IView_2 {
    	// (undocumented)
    toJSON(): object;
}

// @public (undocumented)
export interface ISerializedBranchNode {
    	// (undocumented)
    data: ISerializedNode[];
    	// (undocumented)
    size: number;
    	// (undocumented)
    type: 'branch';
}

// @public (undocumented)
interface ISerializedBranchNode_2 {
    	// (undocumented)
    data: ISerializedNode_2[];
    	// (undocumented)
    size: number;
    	// (undocumented)
    type: 'branch';
}

// @public (undocumented)
export interface ISerializedGrid {
    	// (undocumented)
    height: number;
    	// (undocumented)
    orientation: Orientation;
    	// (undocumented)
    root: ISerializedNode;
    	// (undocumented)
    width: number;
}

// @public (undocumented)
interface ISerializedGridView {
    	// (undocumented)
    height: number;
    	// (undocumented)
    orientation: Orientation;
    	// (undocumented)
    root: ISerializedNode_2;
    	// (undocumented)
    width: number;
}

// @public (undocumented)
export interface ISerializedLeafNode {
    	// (undocumented)
    data: any;
    	// (undocumented)
    size: number;
    	// (undocumented)
    type: 'leaf';
    	// (undocumented)
    visible?: boolean;
}

// @public (undocumented)
interface ISerializedLeafNode_2 {
    	// (undocumented)
    data: any;
    	// (undocumented)
    size: number;
    	// (undocumented)
    type: 'leaf';
    	// (undocumented)
    visible?: boolean;
}

// @public (undocumented)
export type ISerializedNode = ISerializedLeafNode | ISerializedBranchNode;

// @public (undocumented)
type ISerializedNode_2 = ISerializedLeafNode_2 | ISerializedBranchNode_2;

// @public (undocumented)
export function isGridBranchNode<T extends IView>(node: GridNode<T>): node is GridBranchNode<T>;

// @public (undocumented)
interface ISplitViewStyles {
    	// (undocumented)
    readonly separatorBorder: Color;
}

// @public
interface IVerticalSashLayoutProvider {
    	// (undocumented)
    getVerticalSashHeight?(sash: Sash): number;
    	// (undocumented)
    getVerticalSashLeft(sash: Sash): number;
    	// (undocumented)
    getVerticalSashTop?(sash: Sash): number;
}

// @public (undocumented)
interface IVerticalSashOptions extends ISashOptions {
    	// (undocumented)
    readonly orientation: Orientation.VERTICAL;
}

// @public
export interface IView extends IView_2 {
    	readonly preferredHeight?: number;
    	readonly preferredWidth?: number;
}

// @public
interface IView_2 {
    	readonly element: HTMLElement;
    	layout(width: number, height: number, top: number, left: number): void;
    	readonly maximumHeight: number;
    	readonly maximumWidth: number;
    	readonly minimumHeight: number;
    	readonly minimumWidth: number;
    	readonly onDidChange: Event_2<IViewSize | undefined>;
    	readonly priority?: LayoutPriority;
    	readonly proportionalLayout?: boolean;
    	setBoundarySashes?(sashes: IBoundarySashes): void;
    	setVisible?(visible: boolean): void;
    	readonly snap?: boolean;
}

// @public
interface IView_3<TLayoutContext = undefined> {
    	readonly element: HTMLElement;
    	layout(size: number, offset: number, context: TLayoutContext | undefined): void;
    	readonly maximumSize: number;
    	readonly minimumSize: number;
    	readonly onDidChange: Event_2<number | undefined>;
    	readonly priority?: LayoutPriority;
    	readonly proportionalLayout?: boolean;
    	setVisible?(visible: boolean): void;
    	readonly snap?: boolean;
}

// @public (undocumented)
export interface IViewDeserializer<T extends ISerializableView> {
    	// (undocumented)
    fromJSON(json: any): T;
}

// @public (undocumented)
interface IViewDeserializer_2<T extends ISerializableView_2> {
    	// (undocumented)
    fromJSON(json: any): T;
}

// @public (undocumented)
export interface IViewSize {
    	// (undocumented)
    readonly height: number;
    	// (undocumented)
    readonly width: number;
}

// @public (undocumented)
class LayoutController {
    	constructor(isLayoutEnabled: boolean);
    	// (undocumented)
    isLayoutEnabled: boolean;
}

// @public (undocumented)
export const enum LayoutPriority {
    	// (undocumented)
    High = 2,
    	// (undocumented)
    Low = 1,
    	// (undocumented)
    Normal = 0,
}

// @public (undocumented)
class LeafNode implements IView_3<ILayoutContext>, IDisposable {
    	constructor(
    		view: IView_2,
    		orientation: Orientation,
    		layoutController: LayoutController,
    		orthogonalSize: number,
    		size?: number,
    	);
    	// (undocumented)
    get boundarySashes(): IRelativeBoundarySashes;
    	set boundarySashes(boundarySashes: IRelativeBoundarySashes);
    	// (undocumented)
    dispose(): void;
    	// (undocumented)
    get element(): HTMLElement;
    	// (undocumented)
    get height(): number;
    	// (undocumented)
    layout(size: number, offset: number, ctx: ILayoutContext | undefined): void;
    	// (undocumented)
    readonly layoutController: LayoutController;
    	// (undocumented)
    get left(): number;
    	// (undocumented)
    get linkedHeightNode(): LeafNode | undefined;
    	set linkedHeightNode(node: LeafNode | undefined);
    	// (undocumented)
    get linkedWidthNode(): LeafNode | undefined;
    	set linkedWidthNode(node: LeafNode | undefined);
    	// (undocumented)
    get maximumOrthogonalSize(): number;
    	// (undocumented)
    get maximumSize(): number;
    	// (undocumented)
    get minimumOrthogonalSize(): number;
    	// (undocumented)
    get minimumSize(): number;
    	// (undocumented)
    readonly onDidChange: Event_2<number | undefined>;
    	// (undocumented)
    readonly onDidSashReset: Event_2<GridLocation>;
    	// (undocumented)
    readonly onDidScroll: Event_2<void>;
    	// (undocumented)
    readonly orientation: Orientation;
    	// (undocumented)
    get orthogonalSize(): number;
    	// (undocumented)
    get priority(): LayoutPriority | undefined;
    	// (undocumented)
    get proportionalLayout(): boolean;
    	// (undocumented)
    setVisible(visible: boolean): void;
    	// (undocumented)
    get size(): number;
    	// (undocumented)
    get snap(): boolean | undefined;
    	// (undocumented)
    get top(): number;
    	// (undocumented)
    readonly view: IView_2;
    	// (undocumented)
    get width(): number;
}

// @public (undocumented)
type Node_2 = BranchNode | LeafNode;

// @public (undocumented)
export const enum Orientation {
    	// (undocumented)
    HORIZONTAL = 1,
    	// (undocumented)
    VERTICAL = 0,
}

// @public (undocumented)
export function orthogonal(orientation: Orientation): Orientation;

// @public (undocumented)
enum OrthogonalEdge {
    	// (undocumented)
    East = 'east',
    	// (undocumented)
    North = 'north',
    	// (undocumented)
    South = 'south',
    	// (undocumented)
    West = 'west',
}

// @public (undocumented)
class RGBA {
    	constructor(r: number, g: number, b: number, a?: number);
    	readonly a: number;
    	readonly b: number;
    	// (undocumented)
    static equals(a: RGBA, b: RGBA): boolean;
    	readonly g: number;
    	readonly r: number;
    	// (undocumented)
    _rgbaBrand: void;
}

// @public (undocumented)
export function sanitizeGridNodeDescriptor<T>(nodeDescriptor: GridNodeDescriptor<T>, rootNode: boolean): void;

// @public
class Sash extends Disposable {
    	constructor(
    		container: HTMLElement,
    		verticalLayoutProvider: IVerticalSashLayoutProvider,
    		options: IVerticalSashOptions,
    	);
    	constructor(
    		container: HTMLElement,
    		horizontalLayoutProvider: IHorizontalSashLayoutProvider,
    		options: IHorizontalSashOptions,
    	);
    	clearSashHoverState(): void;
    	// (undocumented)
    dispose(): void;
    	layout(): void;
    	linkedSash: Sash | undefined;
    	readonly onDidChange: Event_2<ISashEvent>;
    	readonly onDidEnd: Event_2<void>;
    	readonly onDidReset: Event_2<void>;
    	readonly onDidStart: Event_2<ISashEvent>;
    	// (undocumented)
    get orthogonalEndSash(): Sash | undefined;
    	set orthogonalEndSash(sash: Sash | undefined);
    	// (undocumented)
    get orthogonalStartSash(): Sash | undefined;
    	set orthogonalStartSash(sash: Sash | undefined);
    	// (undocumented)
    get state(): SashState;
    	set state(state: SashState);
    	}

// @public (undocumented)
const enum SashState {
    	AtMaximum = 2,
    	AtMinimum = 1,
    	Disabled = 0,
    	Enabled = 3,
}

// @public
export class SerializableGrid<T extends ISerializableView> extends Grid<T> {
    	static deserialize<T extends ISerializableView>(
    		json: ISerializedGrid,
    		deserializer: IViewDeserializer<T>,
    		options?: IGridOptions,
    	): SerializableGrid<T>;
    	static from<T extends ISerializableView>(
    		gridDescriptor: GridDescriptor<T>,
    		options?: IGridOptions,
    	): SerializableGrid<T>;
    	// (undocumented)
    layout(width: number, height: number, top?: number, left?: number): void;
    	serialize(): ISerializedGrid;
    	}

// @public (undocumented)
export type Sizing = DistributeSizing | SplitSizing | InvisibleSizing;

// @public (undocumented)
export namespace Sizing {
    	const // (undocumented)
    Distribute: DistributeSizing;
    	const // (undocumented)
    Split: SplitSizing;
    	// (undocumented)
    export function Invisible(cachedVisibleSize: number): InvisibleSizing;
}

// @public
type Sizing_2 = DistributeSizing_2 | SplitSizing_2 | InvisibleSizing_2;

// @public (undocumented)
namespace Sizing_2 {
    	const Distribute: DistributeSizing_2;
    	function Invisible(cachedVisibleSize: number): InvisibleSizing_2;
    	function Split(index: number): SplitSizing_2;
}

// @public (undocumented)
export type SplitSizing = {
    	type: 'split';
};

// @public
type SplitSizing_2 = {
    	type: 'split';
    	index: number;
};

// (No @packageDocumentation comment for this package)

```
