## API Report File for "@sussudio/base/common/observableImpl/logging"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
class AutorunObserver implements IObserver, IReader, IDisposable {
    	constructor(
    		debugName: string,
    		runFn: (reader: IReader) => void,
    		_handleChange: ((context: IChangeContext) => boolean) | undefined,
    	);
    	// (undocumented)
    beginUpdate(): void;
    	// (undocumented)
    readonly debugName: string;
    	// (undocumented)
    get dependencies(): Set<IObservable<any, void>>;
    	// (undocumented)
    dispose(): void;
    	// (undocumented)
    endUpdate(): void;
    	// (undocumented)
    handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;
    	// (undocumented)
    needsToRun: boolean;
    	// (undocumented)
    subscribeTo<T>(observable: IObservable<T>): void;
    	// (undocumented)
    toString(): string;
    	}

// @public (undocumented)
abstract class BaseObservable<T, _TChange = void> extends ConvenientObservable<T, _TChange> {
    	// @sealed (undocumented)
    addObserver(observer: IObserver): void;
    	// (undocumented)
    protected readonly observers: Set<IObserver>;
    	// (undocumented)
    protected onFirstObserverAdded(): void;
    	// (undocumented)
    protected onLastObserverRemoved(): void;
    	// @sealed (undocumented)
    removeObserver(observer: IObserver): void;
}

// @public (undocumented)
export class ConsoleObservableLogger implements IObservableLogger {
    	// (undocumented)
    formatChanges(changes: Set<IObservable<any, any>>): ConsoleText | undefined;
    	// (undocumented)
    handleAutorunCreated(autorun: AutorunObserver): void;
    	// (undocumented)
    handleAutorunTriggered(autorun: AutorunObserver): void;
    	// (undocumented)
    handleBeginTransaction(transaction: TransactionImpl): void;
    	// (undocumented)
    handleDerivedCreated(derived: Derived<unknown>): void;
    	// (undocumented)
    handleDerivedRecomputed(derived: Derived<unknown>, info: IChangeInformation): void;
    	// (undocumented)
    handleEndTransaction(): void;
    	// (undocumented)
    handleFromEventObservableTriggered(observable: FromEventObservable<any, any>, info: IChangeInformation): void;
    	// (undocumented)
    handleObservableChanged(observable: IObservable<unknown, unknown>, info: IChangeInformation): void;
    	}

// @public (undocumented)
type ConsoleText =
	| (ConsoleText | undefined)[]
	| {
    			text: string;
    			style: string;
    			data?: Record<string, unknown>;
    	  }
	| {
    			data: Record<string, unknown>;
    	  };

// @public (undocumented)
abstract class ConvenientObservable<T, _TChange> implements IObservable<T, _TChange> {
    	// (undocumented)
    abstract addObserver(observer: IObserver): void;
    	// (undocumented)
    abstract get debugName(): string;
    	// (undocumented)
    abstract get(): T;
    	// @sealed (undocumented)
    map<TNew>(fn: (value: T) => TNew): IObservable<TNew>;
    	// @sealed (undocumented)
    read(reader: IReader): T;
    	// (undocumented)
    abstract removeObserver(observer: IObserver): void;
    	// (undocumented)
    get TChange(): _TChange;
}

// @public (undocumented)
class Derived<T> extends BaseObservable<T, void> implements IReader, IObserver {
    	constructor(_debugName: string | (() => string), computeFn: (reader: IReader) => T);
    	// (undocumented)
    beginUpdate(): void;
    	// (undocumented)
    get debugName(): string;
    	// (undocumented)
    get dependencies(): ReadonlySet<IObservable<any>>;
    	// (undocumented)
    endUpdate(): void;
    	// (undocumented)
    get(): T;
    	// (undocumented)
    handleChange<T, TChange>(_observable: IObservable<T, TChange>, _change: TChange): void;
    	// (undocumented)
    protected onLastObserverRemoved(): void;
    	// (undocumented)
    subscribeTo<T>(observable: IObservable<T>): void;
    	// (undocumented)
    toString(): string;
    	}

// @public
class DisposableStore implements IDisposable {
    	constructor();
    	add<T extends IDisposable>(o: T): T;
    	clear(): void;
    	// (undocumented)
    static DISABLE_DISPOSED_WARNING: boolean;
    	dispose(): void;
    	// (undocumented)
    get isDisposed(): boolean;
    	}

// @public
interface Event_2<T> {
    	// (undocumented)
    (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
}

// @public (undocumented)
namespace Event_2 {
    	const // (undocumented)
    None: Event_2<any>;
    	function accumulate<T>(event: Event_2<T>, delay?: number, disposable?: DisposableStore): Event_2<T[]>;
    	function any<T>(...events: Event_2<T>[]): Event_2<T>;
    	// (undocumented)
    function any(...events: Event_2<any>[]): Event_2<void>;
    	function buffer<T>(event: Event_2<T>, flushAfterTimeout?: boolean, _buffer?: T[]): Event_2<T>;
    	// (undocumented)
    function chain<T>(event: Event_2<T>): IChainableEvent<T>;
    	function debounce<T>(
    		event: Event_2<T>,
    		merge: (last: T | undefined, event: T) => T,
    		delay?: number,
    		leading?: boolean,
    		leakWarningThreshold?: number,
    		disposable?: DisposableStore,
    	): Event_2<T>;
    	function debounce<I, O>(
    		event: Event_2<I>,
    		merge: (last: O | undefined, event: I) => O,
    		delay?: number,
    		leading?: boolean,
    		leakWarningThreshold?: number,
    		disposable?: DisposableStore,
    	): Event_2<O>;
    	function defer(event: Event_2<unknown>, disposable?: DisposableStore): Event_2<void>;
    	// (undocumented)
    interface DOMEventEmitter {
        		// (undocumented)
        addEventListener(event: string | symbol, listener: Function): void;
        		// (undocumented)
        removeEventListener(event: string | symbol, listener: Function): void;
        	}
    	function filter<T, U>(event: Event_2<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event_2<T>;
    	// (undocumented)
    function filter<T>(event: Event_2<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event_2<T>;
    	// (undocumented)
    function filter<T, R>(event: Event_2<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event_2<R>;
    	function forEach<I>(event: Event_2<I>, each: (i: I) => void, disposable?: DisposableStore): Event_2<I>;
    	// (undocumented)
    function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map?: (...args: any[]) => T): Event_2<T>;
    	// (undocumented)
    function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map?: (...args: any[]) => T): Event_2<T>;
    	// (undocumented)
    function fromObservable<T>(obs: IObservable<T, any>, store?: DisposableStore): Event_2<T>;
    	// (undocumented)
    interface IChainableEvent<T> extends IDisposable {
        		// (undocumented)
        debounce(
        			merge: (last: T | undefined, event: T) => T,
        			delay?: number,
        			leading?: boolean,
        			leakWarningThreshold?: number,
        		): IChainableEvent<T>;
        		// (undocumented)
        debounce<R>(
        			merge: (last: R | undefined, event: T) => R,
        			delay?: number,
        			leading?: boolean,
        			leakWarningThreshold?: number,
        		): IChainableEvent<R>;
        		// (undocumented)
        event: Event_2<T>;
        		// (undocumented)
        filter(fn: (e: T) => boolean): IChainableEvent<T>;
        		// (undocumented)
        filter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;
        		// (undocumented)
        forEach(fn: (i: T) => void): IChainableEvent<T>;
        		// (undocumented)
        latch(): IChainableEvent<T>;
        		// (undocumented)
        map<O>(fn: (i: T) => O): IChainableEvent<O>;
        		// (undocumented)
        on(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
        		// (undocumented)
        once(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;
        		// (undocumented)
        reduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;
        	}
    	function latch<T>(event: Event_2<T>, equals?: (a: T, b: T) => boolean, disposable?: DisposableStore): Event_2<T>;
    	function map<I, O>(event: Event_2<I>, map: (i: I) => O, disposable?: DisposableStore): Event_2<O>;
    	// (undocumented)
    interface NodeEventEmitter {
        		// (undocumented)
        on(event: string | symbol, listener: Function): unknown;
        		// (undocumented)
        removeListener(event: string | symbol, listener: Function): unknown;
        	}
    	function once<T>(event: Event_2<T>): Event_2<T>;
    	function reduce<I, O>(
    		event: Event_2<I>,
    		merge: (last: O | undefined, event: I) => O,
    		initial?: O,
    		disposable?: DisposableStore,
    	): Event_2<O>;
    	// (undocumented)
    function runAndSubscribe<T>(event: Event_2<T>, handler: (e: T | undefined) => any): IDisposable;
    	// (undocumented)
    function runAndSubscribeWithStore<T>(
    		event: Event_2<T>,
    		handler: (e: T | undefined, disposableStore: DisposableStore) => any,
    	): IDisposable;
    	function signal<T>(event: Event_2<T>): Event_2<void>;
    	function split<T, U>(
    		event: Event_2<T | U>,
    		isT: (e: T | U) => e is T,
    		disposable?: DisposableStore,
    	): [Event_2<T>, Event_2<U>];
    	// (undocumented)
    function toPromise<T>(event: Event_2<T>): Promise<T>;
}

// @public (undocumented)
class FromEventObservable<TArgs, T> extends BaseObservable<T> {
    	constructor(event: Event_2<TArgs>, getValue: (args: TArgs | undefined) => T);
    	// (undocumented)
    get debugName(): string;
    	// (undocumented)
    get(): T;
    	// (undocumented)
    protected onFirstObserverAdded(): void;
    	// (undocumented)
    protected onLastObserverRemoved(): void;
    	}

// @public (undocumented)
export function getLogger(): IObservableLogger | undefined;

// @public (undocumented)
interface IChangeContext {
    	// (undocumented)
    readonly change: unknown;
    	// (undocumented)
    readonly changedObservable: IObservable<any, any>;
    	// (undocumented)
    didChange<T, TChange>(
    		observable: IObservable<T, TChange>,
    	): this is {
        		change: TChange;
        	};
}

// @public (undocumented)
interface IChangeInformation {
    	// (undocumented)
    change: unknown;
    	// (undocumented)
    didChange: boolean;
    	// (undocumented)
    newValue: unknown;
    	// (undocumented)
    oldValue: unknown;
}

// @public
interface IDisposable {
    	// (undocumented)
    dispose(): void;
}

// @public (undocumented)
interface IObservable<T, _TChange = void> {
    	addObserver(observer: IObserver): void;
    	// (undocumented)
    readonly debugName: string;
    	get(): T;
    	// (undocumented)
    map<TNew>(fn: (value: T) => TNew): IObservable<TNew>;
    	read(reader: IReader): T;
    	// (undocumented)
    removeObserver(observer: IObserver): void;
    	// (undocumented)
    readonly TChange: _TChange;
}

// @public (undocumented)
export interface IObservableLogger {
    	// (undocumented)
    handleAutorunCreated(autorun: AutorunObserver): void;
    	// (undocumented)
    handleAutorunTriggered(autorun: AutorunObserver): void;
    	// (undocumented)
    handleBeginTransaction(transaction: TransactionImpl): void;
    	// (undocumented)
    handleDerivedCreated(observable: Derived<unknown>): void;
    	// (undocumented)
    handleDerivedRecomputed(observable: Derived<unknown>, info: IChangeInformation): void;
    	// (undocumented)
    handleEndTransaction(): void;
    	// (undocumented)
    handleFromEventObservableTriggered(observable: FromEventObservable<any, any>, info: IChangeInformation): void;
    	// (undocumented)
    handleObservableChanged(observable: ObservableValue<unknown, unknown>, info: IChangeInformation): void;
}

// @public (undocumented)
interface IObserver {
    	beginUpdate<T>(observable: IObservable<T>): void;
    	endUpdate<T>(observable: IObservable<T>): void;
    	handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;
}

// @public (undocumented)
interface IReader {
    	subscribeTo<T>(observable: IObservable<T, any>): void;
}

// @public (undocumented)
interface ISettable<T, TChange = void> {
    	// (undocumented)
    set(value: T, transaction: ITransaction | undefined, change: TChange): void;
}

// @public (undocumented)
interface ISettableObservable<T, _TChange = void> extends IObservable<T, _TChange>, ISettable<T, _TChange> {}

// @public (undocumented)
interface ITransaction {
    	updateObserver(observer: IObserver, observable: IObservable<any, any>): void;
}

// @public (undocumented)
class ObservableValue<T, _TChange = void>
	extends BaseObservable<T, _TChange>
	implements ISettableObservable<T, _TChange>
    {
    	constructor(debugName: string, initialValue: T);
    	// (undocumented)
    readonly debugName: string;
    	// (undocumented)
    get(): T;
    	// (undocumented)
    set(value: T, tx: ITransaction | undefined, change: _TChange): void;
    	// (undocumented)
    toString(): string;
    	}

// @public (undocumented)
export function setLogger(logger: IObservableLogger): void;

// @public (undocumented)
class TransactionImpl implements ITransaction {
    	constructor(fn: Function, _getDebugName?: (() => string) | undefined);
    	// (undocumented)
    finish(): void;
    	// (undocumented)
    getDebugName(): string | undefined;
    	// (undocumented)
    updateObserver(observer: IObserver, observable: IObservable<any>): void;
    	}

// (No @packageDocumentation comment for this package)

```
