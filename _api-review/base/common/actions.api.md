## API Report File for "@sussudio/base/common/actions"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export class Action extends Disposable implements IAction {
    	constructor(
    		id: string,
    		label?: string,
    		cssClass?: string,
    		enabled?: boolean,
    		actionCallback?: (event?: unknown) => unknown,
    	);
    	// (undocumented)
    protected readonly _actionCallback?: (event?: unknown) => unknown;
    	// (undocumented)
    get checked(): boolean | undefined;
    	set checked(value: boolean | undefined);
    	// (undocumented)
    protected _checked?: boolean;
    	// (undocumented)
    get class(): string | undefined;
    	set class(value: string | undefined);
    	// (undocumented)
    protected _cssClass: string | undefined;
    	// (undocumented)
    get enabled(): boolean;
    	set enabled(value: boolean);
    	// (undocumented)
    protected _enabled: boolean;
    	// (undocumented)
    get id(): string;
    	// (undocumented)
    protected readonly _id: string;
    	// (undocumented)
    get label(): string;
    	set label(value: string);
    	// (undocumented)
    protected _label: string;
    	// (undocumented)
    readonly onDidChange: Event_2<IActionChangeEvent>;
    	// (undocumented)
    protected _onDidChange: Emitter<IActionChangeEvent>;
    	// (undocumented)
    run(event?: unknown, data?: ITelemetryData): Promise<void>;
    	// (undocumented)
    protected _setChecked(value: boolean | undefined): void;
    	// (undocumented)
    protected _setClass(value: string | undefined): void;
    	// (undocumented)
    protected _setEnabled(value: boolean): void;
    	// (undocumented)
    protected _setTooltip(value: string): void;
    	// (undocumented)
    get tooltip(): string;
    	set tooltip(value: string);
    	// (undocumented)
    protected _tooltip: string | undefined;
}

// @public (undocumented)
export class ActionRunner extends Disposable implements IActionRunner {
    	// (undocumented)
    readonly onDidRun: Event_2<IRunEvent>;
    	// (undocumented)
    readonly onWillRun: Event_2<IRunEvent>;
    	// (undocumented)
    run(action: IAction, context?: unknown): Promise<void>;
    	// (undocumented)
    protected runAction(action: IAction, context?: unknown): Promise<void>;
}

// @public
abstract class Disposable implements IDisposable {
    	constructor();
    	// (undocumented)
    dispose(): void;
    	static readonly None: Readonly<IDisposable>;
    	protected _register<T extends IDisposable>(o: T): T;
    	// (undocumented)
    protected readonly _store: DisposableStore;
}

// @public
class DisposableStore implements IDisposable {
    	constructor();
    	add<T extends IDisposable>(o: T): T;
    	clear(): void;
    	// (undocumented)
    static DISABLE_DISPOSED_WARNING: boolean;
    	dispose(): void;
    	// (undocumented)
    get isDisposed(): boolean;
    	}

// @public
class Emitter<T> {
    	constructor(options?: EmitterOptions);
    	// (undocumented)
    dispose(): void;
    	get event(): Event_2<T>;
    	fire(event: T): void;
    	// (undocumented)
    hasListeners(): boolean;
    	// (undocumented)
    protected _listeners?: LinkedList<Listener<T>>;
    	}

// @public (undocumented)
interface EmitterOptions {
    	deliveryQueue?: EventDeliveryQueue;
    	leakWarningThreshold?: number;
    	onDidAddFirstListener?: Function;
    	onDidAddListener?: Function;
    	onDidRemoveLastListener?: Function;
    	onWillAddFirstListener?: Function;
    	_profName?: string;
}

// @public (undocumented)
export class EmptySubmenuAction extends Action {
    	constructor();
    	// (undocumented)
    static readonly ID = 'vs.actions.empty';
}

// @public
interface Event_2<T> {
    	// (undocumented)
    (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
}

// @public (undocumented)
namespace Event_2 {
    	const // (undocumented)
    None: Event_2<any>;
    	function accumulate<T>(event: Event_2<T>, delay?: number, disposable?: DisposableStore): Event_2<T[]>;
    	function any<T>(...events: Event_2<T>[]): Event_2<T>;
    	// (undocumented)
    function any(...events: Event_2<any>[]): Event_2<void>;
    	function buffer<T>(event: Event_2<T>, flushAfterTimeout?: boolean, _buffer?: T[]): Event_2<T>;
    	// (undocumented)
    function chain<T>(event: Event_2<T>): IChainableEvent<T>;
    	function debounce<T>(
    		event: Event_2<T>,
    		merge: (last: T | undefined, event: T) => T,
    		delay?: number,
    		leading?: boolean,
    		leakWarningThreshold?: number,
    		disposable?: DisposableStore,
    	): Event_2<T>;
    	function debounce<I, O>(
    		event: Event_2<I>,
    		merge: (last: O | undefined, event: I) => O,
    		delay?: number,
    		leading?: boolean,
    		leakWarningThreshold?: number,
    		disposable?: DisposableStore,
    	): Event_2<O>;
    	function defer(event: Event_2<unknown>, disposable?: DisposableStore): Event_2<void>;
    	// (undocumented)
    interface DOMEventEmitter {
        		// (undocumented)
        addEventListener(event: string | symbol, listener: Function): void;
        		// (undocumented)
        removeEventListener(event: string | symbol, listener: Function): void;
        	}
    	function filter<T, U>(event: Event_2<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event_2<T>;
    	// (undocumented)
    function filter<T>(event: Event_2<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event_2<T>;
    	// (undocumented)
    function filter<T, R>(event: Event_2<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event_2<R>;
    	function forEach<I>(event: Event_2<I>, each: (i: I) => void, disposable?: DisposableStore): Event_2<I>;
    	// (undocumented)
    function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map?: (...args: any[]) => T): Event_2<T>;
    	// (undocumented)
    function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map?: (...args: any[]) => T): Event_2<T>;
    	// (undocumented)
    function fromObservable<T>(obs: IObservable<T, any>, store?: DisposableStore): Event_2<T>;
    	// (undocumented)
    interface IChainableEvent<T> extends IDisposable {
        		// (undocumented)
        debounce(
        			merge: (last: T | undefined, event: T) => T,
        			delay?: number,
        			leading?: boolean,
        			leakWarningThreshold?: number,
        		): IChainableEvent<T>;
        		// (undocumented)
        debounce<R>(
        			merge: (last: R | undefined, event: T) => R,
        			delay?: number,
        			leading?: boolean,
        			leakWarningThreshold?: number,
        		): IChainableEvent<R>;
        		// (undocumented)
        event: Event_2<T>;
        		// (undocumented)
        filter(fn: (e: T) => boolean): IChainableEvent<T>;
        		// (undocumented)
        filter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;
        		// (undocumented)
        forEach(fn: (i: T) => void): IChainableEvent<T>;
        		// (undocumented)
        latch(): IChainableEvent<T>;
        		// (undocumented)
        map<O>(fn: (i: T) => O): IChainableEvent<O>;
        		// (undocumented)
        on(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
        		// (undocumented)
        once(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;
        		// (undocumented)
        reduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;
        	}
    	function latch<T>(event: Event_2<T>, equals?: (a: T, b: T) => boolean, disposable?: DisposableStore): Event_2<T>;
    	function map<I, O>(event: Event_2<I>, map: (i: I) => O, disposable?: DisposableStore): Event_2<O>;
    	// (undocumented)
    interface NodeEventEmitter {
        		// (undocumented)
        on(event: string | symbol, listener: Function): unknown;
        		// (undocumented)
        removeListener(event: string | symbol, listener: Function): unknown;
        	}
    	function once<T>(event: Event_2<T>): Event_2<T>;
    	function reduce<I, O>(
    		event: Event_2<I>,
    		merge: (last: O | undefined, event: I) => O,
    		initial?: O,
    		disposable?: DisposableStore,
    	): Event_2<O>;
    	// (undocumented)
    function runAndSubscribe<T>(event: Event_2<T>, handler: (e: T | undefined) => any): IDisposable;
    	// (undocumented)
    function runAndSubscribeWithStore<T>(
    		event: Event_2<T>,
    		handler: (e: T | undefined, disposableStore: DisposableStore) => any,
    	): IDisposable;
    	function signal<T>(event: Event_2<T>): Event_2<void>;
    	function split<T, U>(
    		event: Event_2<T | U>,
    		isT: (e: T | U) => e is T,
    		disposable?: DisposableStore,
    	): [Event_2<T>, Event_2<U>];
    	// (undocumented)
    function toPromise<T>(event: Event_2<T>): Promise<T>;
}

// @public (undocumented)
class EventDeliveryQueue {
    	// (undocumented)
    clear<T>(emitter: Emitter<T>): void;
    	// (undocumented)
    deliver(): void;
    	// (undocumented)
    push<T>(emitter: Emitter<T>, listener: Listener<T>, event: T): void;
    	// (undocumented)
    protected _queue: LinkedList<EventDeliveryQueueElement<any>>;
    	// (undocumented)
    get size(): number;
}

// @public (undocumented)
class EventDeliveryQueueElement<T = any> {
    	constructor(emitter: Emitter<T>, listener: Listener<T>, event: T);
    	// (undocumented)
    readonly emitter: Emitter<T>;
    	// (undocumented)
    readonly event: T;
    	// (undocumented)
    readonly listener: Listener<T>;
}

// @public (undocumented)
export interface IAction {
    	// (undocumented)
    checked?: boolean;
    	// (undocumented)
    class: string | undefined;
    	// (undocumented)
    enabled: boolean;
    	// (undocumented)
    readonly id: string;
    	// (undocumented)
    label: string;
    	// (undocumented)
    run(event?: unknown): unknown;
    	// (undocumented)
    tooltip: string;
}

// @public (undocumented)
export interface IActionChangeEvent {
    	// (undocumented)
    readonly checked?: boolean;
    	// (undocumented)
    readonly class?: string;
    	// (undocumented)
    readonly enabled?: boolean;
    	// (undocumented)
    readonly label?: string;
    	// (undocumented)
    readonly tooltip?: string;
}

// @public (undocumented)
export interface IActionRunner extends IDisposable {
    	// (undocumented)
    readonly onDidRun: Event_2<IRunEvent>;
    	// (undocumented)
    readonly onWillRun: Event_2<IRunEvent>;
    	// (undocumented)
    run(action: IAction, context?: unknown): unknown;
}

// @public
interface IDisposable {
    	// (undocumented)
    dispose(): void;
}

// @public (undocumented)
interface IObservable<T, _TChange = void> {
    	addObserver(observer: IObserver): void;
    	// (undocumented)
    readonly debugName: string;
    	get(): T;
    	// (undocumented)
    map<TNew>(fn: (value: T) => TNew): IObservable<TNew>;
    	read(reader: IReader): T;
    	// (undocumented)
    removeObserver(observer: IObserver): void;
    	// (undocumented)
    readonly TChange: _TChange;
}

// @public (undocumented)
interface IObserver {
    	beginUpdate<T>(observable: IObservable<T>): void;
    	endUpdate<T>(observable: IObservable<T>): void;
    	handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;
}

// @public (undocumented)
interface IReader {
    	subscribeTo<T>(observable: IObservable<T, any>): void;
}

// @public (undocumented)
export interface IRunEvent {
    	// (undocumented)
    readonly action: IAction;
    	// (undocumented)
    readonly error?: Error;
}

// @public (undocumented)
export interface ITelemetryData {
    	// (undocumented)
    [key: string]: unknown;
    	// (undocumented)
    readonly from?: string;
    	// (undocumented)
    readonly target?: string;
}

// @public (undocumented)
class LinkedList<E> {
    	// (undocumented)
    [Symbol.iterator](): Iterator<E>;
    	// (undocumented)
    clear(): void;
    	// (undocumented)
    isEmpty(): boolean;
    	// (undocumented)
    pop(): E | undefined;
    	// (undocumented)
    push(element: E): () => void;
    	// (undocumented)
    shift(): E | undefined;
    	// (undocumented)
    get size(): number;
    	// (undocumented)
    unshift(element: E): () => void;
}

// @public (undocumented)
class Listener<T> {
    	constructor(callback: (e: T) => void, callbackThis: any | undefined, stack: Stacktrace | undefined);
    	// (undocumented)
    readonly callback: (e: T) => void;
    	// (undocumented)
    readonly callbackThis: any | undefined;
    	// (undocumented)
    invoke(e: T): void;
    	// (undocumented)
    readonly stack: Stacktrace | undefined;
    	// (undocumented)
    readonly subscription: SafeDisposable;
}

// @public
class SafeDisposable implements IDisposable {
    	constructor();
    	// (undocumented)
    dispose: () => void;
    	// (undocumented)
    isset: () => boolean;
    	// (undocumented)
    set(fn: Function): this;
    	// (undocumented)
    unset: () => void;
}

// @public (undocumented)
export class Separator implements IAction {
    	// (undocumented)
    readonly checked: boolean;
    	// (undocumented)
    readonly class: string;
    	// (undocumented)
    readonly enabled: boolean;
    	// (undocumented)
    static readonly ID = 'vs.actions.separator';
    	// (undocumented)
    readonly id: string;
    	static join(...actionLists: readonly IAction[][]): IAction[];
    	// (undocumented)
    readonly label: string;
    	// (undocumented)
    run(): Promise<void>;
    	// (undocumented)
    readonly tooltip: string;
}

// @public (undocumented)
class Stacktrace {
    	// (undocumented)
    static create(): Stacktrace;
    	// (undocumented)
    print(): void;
    	// (undocumented)
    readonly value: string;
}

// @public (undocumented)
export class SubmenuAction implements IAction {
    	constructor(id: string, label: string, actions: readonly IAction[], cssClass?: string);
    	// (undocumented)
    get actions(): readonly IAction[];
    	// (undocumented)
    readonly checked: undefined;
    	// (undocumented)
    readonly class: string | undefined;
    	// (undocumented)
    readonly enabled: boolean;
    	// (undocumented)
    readonly id: string;
    	// (undocumented)
    readonly label: string;
    	// (undocumented)
    run(): Promise<void>;
    	// (undocumented)
    readonly tooltip: string;
}

// @public (undocumented)
export function toAction(props: {
    	id: string;
    	label: string;
    	enabled?: boolean;
    	checked?: boolean;
    	run: Function;
}): IAction;

// @public (undocumented)
export type WorkbenchActionExecutedClassification = {
    	owner: 'bpasero';
    	comment: 'TODO @bpasero';
    	id: {
        		classification: 'SystemMetaData';
        		purpose: 'FeatureInsight';
        		comment: 'The identifier of the action that was run.';
        	};
    	from: {
        		classification: 'SystemMetaData';
        		purpose: 'FeatureInsight';
        		comment: 'The name of the component the action was run from.';
        	};
};

// @public (undocumented)
export type WorkbenchActionExecutedEvent = {
    	id: string;
    	from: string;
};

// (No @packageDocumentation comment for this package)

```
