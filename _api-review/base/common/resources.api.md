## API Report File for "@sussudio/base/common/resources"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export const addTrailingPathSeparator: (resource: URI, sep?: string) => URI;

// @public (undocumented)
export const basename: (resource: URI) => string;

// @public (undocumented)
export const basenameOrAuthority: (resource: URI) => string;

// @public
export namespace DataUri {
    	const // (undocumented)
    META_DATA_LABEL = 'label';
    	const // (undocumented)
    META_DATA_DESCRIPTION = 'description';
    	const // (undocumented)
    META_DATA_SIZE = 'size';
    	const // (undocumented)
    META_DATA_MIME = 'mime';
    	// (undocumented)
    export function parseMetaData(dataUri: URI): Map<string, string>;
}

// @public (undocumented)
export const dirname: (resource: URI) => URI;

// @public (undocumented)
export function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[];

// @public (undocumented)
export const extname: (resource: URI) => string;

// @public (undocumented)
export class ExtUri implements IExtUri {
    	constructor(_ignorePathCasing: (uri: URI) => boolean);
    	// (undocumented)
    addTrailingPathSeparator(resource: URI, sep?: string): URI;
    	// (undocumented)
    basename(resource: URI): string;
    	// (undocumented)
    basenameOrAuthority(resource: URI): string;
    	// (undocumented)
    compare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;
    	// (undocumented)
    dirname(resource: URI): URI;
    	// (undocumented)
    extname(resource: URI): string;
    	// (undocumented)
    getComparisonKey(uri: URI, ignoreFragment?: boolean): string;
    	// (undocumented)
    hasTrailingPathSeparator(resource: URI, sep?: string): boolean;
    	// (undocumented)
    ignorePathCasing(uri: URI): boolean;
    	// (undocumented)
    isAbsolutePath(resource: URI): boolean;
    	// (undocumented)
    isEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;
    	// (undocumented)
    isEqualAuthority(a1: string | undefined, a2: string | undefined): boolean;
    	// (undocumented)
    isEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;
    	// (undocumented)
    joinPath(resource: URI, ...pathFragment: string[]): URI;
    	// (undocumented)
    normalizePath(resource: URI): URI;
    	// (undocumented)
    relativePath(from: URI, to: URI): string | undefined;
    	// (undocumented)
    removeTrailingPathSeparator(resource: URI, sep?: string): URI;
    	// (undocumented)
    resolvePath(base: URI, path: string): URI;
}

// @public
export const extUri: ExtUri;

// @public
export const extUriBiasedIgnorePathCase: ExtUri;

// @public
export const extUriIgnorePathCase: ExtUri;

// @public (undocumented)
export const getComparisonKey: (uri: URI, ignoreFragment?: boolean) => string;

// @public (undocumented)
export const hasTrailingPathSeparator: (resource: URI, sep?: string) => boolean;

// @public (undocumented)
export interface IExtUri {
    	addTrailingPathSeparator(resource: URI, sep?: string): URI;
    	basename(resource: URI): string;
    	// (undocumented)
    basenameOrAuthority(resource: URI): string;
    	compare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;
    	dirname(resource: URI): URI;
    	extname(resource: URI): string;
    	getComparisonKey(uri: URI, ignoreFragment?: boolean): string;
    	hasTrailingPathSeparator(resource: URI, sep?: string): boolean;
    	ignorePathCasing(uri: URI): boolean;
    	isAbsolutePath(resource: URI): boolean;
    	isEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;
    	isEqualAuthority(a1: string, a2: string): boolean;
    	isEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;
    	joinPath(resource: URI, ...pathFragment: string[]): URI;
    	normalizePath(resource: URI): URI;
    	// (undocumented)
    relativePath(from: URI, to: URI): string | undefined;
    	removeTrailingPathSeparator(resource: URI, sep?: string): URI;
    	resolvePath(base: URI, path: string): URI;
}

// @public (undocumented)
export const isAbsolutePath: (resource: URI) => boolean;

// @public (undocumented)
export const isEqual: (uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean) => boolean;

// @public (undocumented)
export const isEqualAuthority: (a1: string | undefined, a2: string | undefined) => boolean;

// @public (undocumented)
export const isEqualOrParent: (base: URI, parentCandidate: URI, ignoreFragment?: boolean) => boolean;

// @public (undocumented)
export const joinPath: (resource: URI, ...pathFragment: string[]) => URI;

// @public (undocumented)
export const normalizePath: (resource: URI) => URI;

// @public (undocumented)
export function originalFSPath(uri: URI): string;

// @public (undocumented)
export const relativePath: (from: URI, to: URI) => string | undefined;

// @public (undocumented)
export const removeTrailingPathSeparator: (resource: URI, sep?: string) => URI;

// @public (undocumented)
export const resolvePath: (base: URI, path: string) => URI;

// @public (undocumented)
export function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI;

// @public
class URI implements UriComponents {
    	// @internal
    protected constructor(
    		scheme: string,
    		authority?: string,
    		path?: string,
    		query?: string,
    		fragment?: string,
    		_strict?: boolean,
    	);
    	// @internal
    protected constructor(components: UriComponents);
    	readonly authority: string;
    	static file(path: string): URI;
    	readonly fragment: string;
    	// (undocumented)
    static from(components: {
        		scheme: string;
        		authority?: string;
        		path?: string;
        		query?: string;
        		fragment?: string;
        	}): URI;
    	get fsPath(): string;
    	// (undocumented)
    static isUri(thing: any): thing is URI;
    	static joinPath(uri: URI, ...pathFragment: string[]): URI;
    	static parse(value: string, _strict?: boolean): URI;
    	readonly path: string;
    	readonly query: string;
    	// (undocumented)
    static revive(data: UriComponents | URI): URI;
    	// (undocumented)
    static revive(data: UriComponents | URI | undefined): URI | undefined;
    	// (undocumented)
    static revive(data: UriComponents | URI | null): URI | null;
    	// (undocumented)
    static revive(data: UriComponents | URI | undefined | null): URI | undefined | null;
    	readonly scheme: string;
    	// (undocumented)
    toJSON(): UriComponents;
    	toString(skipEncoding?: boolean): string;
    	// (undocumented)
    with(change: {
        		scheme?: string;
        		authority?: string | null;
        		path?: string | null;
        		query?: string | null;
        		fragment?: string | null;
        	}): URI;
}

// @public (undocumented)
interface UriComponents {
    	// (undocumented)
    authority: string;
    	// (undocumented)
    fragment: string;
    	// (undocumented)
    path: string;
    	// (undocumented)
    query: string;
    	// (undocumented)
    scheme: string;
}

// (No @packageDocumentation comment for this package)

```
