## API Report File for "@sussudio/base/common/async"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export function asPromise<T>(callback: () => T | Thenable<T>): Promise<T>;

// @public
export interface AsyncIterableEmitter<T> {
    	emitMany(values: T[]): void;
    	emitOne(value: T): void;
    	reject(error: Error): void;
}

// @public
export interface AsyncIterableExecutor<T> {
    	// (undocumented)
    (emitter: AsyncIterableEmitter<T>): void | Promise<void>;
}

// @public
export class AsyncIterableObject<T> implements AsyncIterable<T> {
    	// (undocumented)
    [Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined>;
    	constructor(executor: AsyncIterableExecutor<T>);
    	// (undocumented)
    static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T>;
    	// (undocumented)
    coalesce(): AsyncIterableObject<NonNullable<T>>;
    	// (undocumented)
    static EMPTY: AsyncIterableObject<any>;
    	// (undocumented)
    static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T>;
    	// (undocumented)
    filter(filterFn: (item: T) => boolean): AsyncIterableObject<T>;
    	// (undocumented)
    static fromArray<T>(items: T[]): AsyncIterableObject<T>;
    	// (undocumented)
    static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T>;
    	// (undocumented)
    static fromPromises<T>(promises: Promise<T>[]): AsyncIterableObject<T>;
    	// (undocumented)
    static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R>;
    	// (undocumented)
    map<R>(mapFn: (item: T) => R): AsyncIterableObject<R>;
    	// (undocumented)
    static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T>;
    	// (undocumented)
    static toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]>;
    	// (undocumented)
    toPromise(): Promise<T[]>;
}

// @public
export class AutoOpenBarrier extends Barrier {
    	constructor(autoOpenTimeMs: number);
    	// (undocumented)
    open(): void;
    	}

// @public
export class Barrier {
    	constructor();
    	// (undocumented)
    isOpen(): boolean;
    	// (undocumented)
    open(): void;
    	// (undocumented)
    wait(): Promise<boolean>;
}

// @public (undocumented)
export class CancelableAsyncIterableObject<T> extends AsyncIterableObject<T> {
    	constructor(_source: CancellationTokenSource, executor: AsyncIterableExecutor<T>);
    	// (undocumented)
    cancel(): void;
    	}

// @public (undocumented)
export interface CancelablePromise<T> extends Promise<T> {
    	// (undocumented)
    cancel(): void;
}

// @public (undocumented)
interface CancellationToken {
    	readonly isCancellationRequested: boolean;
    	readonly onCancellationRequested: (
    		listener: (e: any) => any,
    		thisArgs?: any,
    		disposables?: IDisposable[],
    	) => IDisposable;
}

// @public (undocumented)
namespace CancellationToken {
    	// (undocumented)
    function isCancellationToken(thing: unknown): thing is CancellationToken;
    	const // (undocumented)
    None: Readonly<CancellationToken>;
    	const // (undocumented)
    Cancelled: Readonly<CancellationToken>;
}

// @public (undocumented)
class CancellationTokenSource {
    	constructor(parent?: CancellationToken);
    	// (undocumented)
    cancel(): void;
    	// (undocumented)
    dispose(cancel?: boolean): void;
    	// (undocumented)
    get token(): CancellationToken;
    	}

// @public (undocumented)
export function createCancelableAsyncIterable<T>(
	callback: (token: CancellationToken) => AsyncIterable<T>,
): CancelableAsyncIterableObject<T>;

// @public (undocumented)
export function createCancelablePromise<T>(
	callback: (token: CancellationToken) => Promise<T>,
): CancelablePromise<T>;

// @public
export class DeferredPromise<T> {
    	constructor();
    	// (undocumented)
    cancel(): void;
    	// (undocumented)
    complete(value: T): Promise<void>;
    	// (undocumented)
    error(err: unknown): Promise<void>;
    	// (undocumented)
    get isRejected(): boolean;
    	// (undocumented)
    get isResolved(): boolean;
    	// (undocumented)
    get isSettled(): boolean;
    	// (undocumented)
    readonly p: Promise<T>;
    	}

// @public
export class Delayer<T> implements IDisposable {
    	constructor(defaultDelay: number | typeof MicrotaskDelay);
    	// (undocumented)
    cancel(): void;
    	// (undocumented)
    defaultDelay: number | typeof MicrotaskDelay;
    	// (undocumented)
    dispose(): void;
    	// (undocumented)
    isTriggered(): boolean;
    	// (undocumented)
    trigger(task: ITask<T | Promise<T>>, delay?: number | typeof MicrotaskDelay): Promise<T>;
}

// @public
abstract class Disposable implements IDisposable {
    	constructor();
    	// (undocumented)
    dispose(): void;
    	static readonly None: Readonly<IDisposable>;
    	protected _register<T extends IDisposable>(o: T): T;
    	// (undocumented)
    protected readonly _store: DisposableStore;
}

// @public
class DisposableStore implements IDisposable {
    	constructor();
    	add<T extends IDisposable>(o: T): T;
    	clear(): void;
    	// (undocumented)
    static DISABLE_DISPOSED_WARNING: boolean;
    	dispose(): void;
    	// (undocumented)
    get isDisposed(): boolean;
    	}

// @public (undocumented)
export function disposableTimeout(handler: () => void, timeout?: number): IDisposable;

// @public
interface Event_2<T> {
    	// (undocumented)
    (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
}

// @public (undocumented)
namespace Event_2 {
    	const // (undocumented)
    None: Event_2<any>;
    	function accumulate<T>(event: Event_2<T>, delay?: number, disposable?: DisposableStore): Event_2<T[]>;
    	function any<T>(...events: Event_2<T>[]): Event_2<T>;
    	// (undocumented)
    function any(...events: Event_2<any>[]): Event_2<void>;
    	function buffer<T>(event: Event_2<T>, flushAfterTimeout?: boolean, _buffer?: T[]): Event_2<T>;
    	// (undocumented)
    function chain<T>(event: Event_2<T>): IChainableEvent<T>;
    	function debounce<T>(
    		event: Event_2<T>,
    		merge: (last: T | undefined, event: T) => T,
    		delay?: number,
    		leading?: boolean,
    		leakWarningThreshold?: number,
    		disposable?: DisposableStore,
    	): Event_2<T>;
    	function debounce<I, O>(
    		event: Event_2<I>,
    		merge: (last: O | undefined, event: I) => O,
    		delay?: number,
    		leading?: boolean,
    		leakWarningThreshold?: number,
    		disposable?: DisposableStore,
    	): Event_2<O>;
    	function defer(event: Event_2<unknown>, disposable?: DisposableStore): Event_2<void>;
    	// (undocumented)
    interface DOMEventEmitter {
        		// (undocumented)
        addEventListener(event: string | symbol, listener: Function): void;
        		// (undocumented)
        removeEventListener(event: string | symbol, listener: Function): void;
        	}
    	function filter<T, U>(event: Event_2<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event_2<T>;
    	// (undocumented)
    function filter<T>(event: Event_2<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event_2<T>;
    	// (undocumented)
    function filter<T, R>(event: Event_2<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event_2<R>;
    	function forEach<I>(event: Event_2<I>, each: (i: I) => void, disposable?: DisposableStore): Event_2<I>;
    	// (undocumented)
    function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map?: (...args: any[]) => T): Event_2<T>;
    	// (undocumented)
    function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map?: (...args: any[]) => T): Event_2<T>;
    	// (undocumented)
    function fromObservable<T>(obs: IObservable<T, any>, store?: DisposableStore): Event_2<T>;
    	// (undocumented)
    interface IChainableEvent<T> extends IDisposable {
        		// (undocumented)
        debounce(
        			merge: (last: T | undefined, event: T) => T,
        			delay?: number,
        			leading?: boolean,
        			leakWarningThreshold?: number,
        		): IChainableEvent<T>;
        		// (undocumented)
        debounce<R>(
        			merge: (last: R | undefined, event: T) => R,
        			delay?: number,
        			leading?: boolean,
        			leakWarningThreshold?: number,
        		): IChainableEvent<R>;
        		// (undocumented)
        event: Event_2<T>;
        		// (undocumented)
        filter(fn: (e: T) => boolean): IChainableEvent<T>;
        		// (undocumented)
        filter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;
        		// (undocumented)
        forEach(fn: (i: T) => void): IChainableEvent<T>;
        		// (undocumented)
        latch(): IChainableEvent<T>;
        		// (undocumented)
        map<O>(fn: (i: T) => O): IChainableEvent<O>;
        		// (undocumented)
        on(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
        		// (undocumented)
        once(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;
        		// (undocumented)
        reduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;
        	}
    	function latch<T>(event: Event_2<T>, equals?: (a: T, b: T) => boolean, disposable?: DisposableStore): Event_2<T>;
    	function map<I, O>(event: Event_2<I>, map: (i: I) => O, disposable?: DisposableStore): Event_2<O>;
    	// (undocumented)
    interface NodeEventEmitter {
        		// (undocumented)
        on(event: string | symbol, listener: Function): unknown;
        		// (undocumented)
        removeListener(event: string | symbol, listener: Function): unknown;
        	}
    	function once<T>(event: Event_2<T>): Event_2<T>;
    	function reduce<I, O>(
    		event: Event_2<I>,
    		merge: (last: O | undefined, event: I) => O,
    		initial?: O,
    		disposable?: DisposableStore,
    	): Event_2<O>;
    	// (undocumented)
    function runAndSubscribe<T>(event: Event_2<T>, handler: (e: T | undefined) => any): IDisposable;
    	// (undocumented)
    function runAndSubscribeWithStore<T>(
    		event: Event_2<T>,
    		handler: (e: T | undefined, disposableStore: DisposableStore) => any,
    	): IDisposable;
    	function signal<T>(event: Event_2<T>): Event_2<void>;
    	function split<T, U>(
    		event: Event_2<T | U>,
    		isT: (e: T | U) => e is T,
    		disposable?: DisposableStore,
    	): [Event_2<T>, Event_2<U>];
    	// (undocumented)
    function toPromise<T>(event: Event_2<T>): Promise<T>;
}

// @public (undocumented)
export function first<T>(
	promiseFactories: ITask<Promise<T>>[],
	shouldStop?: (t: T) => boolean,
	defaultValue?: T | null,
): Promise<T | null>;

// @public
export function firstParallel<T>(
	promiseList: Promise<T>[],
	shouldStop?: (t: T) => boolean,
	defaultValue?: T | null,
): Promise<T | null>;

// @public (undocumented)
export function firstParallel<T, R extends T>(
	promiseList: Promise<T>[],
	shouldStop: (t: T) => t is R,
	defaultValue?: R | null,
): Promise<R | null>;

// @public
interface IDisposable {
    	// (undocumented)
    dispose(): void;
}

// @public (undocumented)
interface IdleDeadline_2 {
    	// (undocumented)
    readonly didTimeout: boolean;
    	// (undocumented)
    timeRemaining(): number;
}
export { IdleDeadline_2 as IdleDeadline }

// @public
export class IdleValue<T> {
    	constructor(executor: () => T);
    	// (undocumented)
    dispose(): void;
    	// (undocumented)
    get isInitialized(): boolean;
    	// (undocumented)
    get value(): T;
    	}

// @public (undocumented)
interface IExtUri {
    	addTrailingPathSeparator(resource: URI, sep?: string): URI;
    	basename(resource: URI): string;
    	// (undocumented)
    basenameOrAuthority(resource: URI): string;
    	compare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;
    	dirname(resource: URI): URI;
    	extname(resource: URI): string;
    	getComparisonKey(uri: URI, ignoreFragment?: boolean): string;
    	hasTrailingPathSeparator(resource: URI, sep?: string): boolean;
    	ignorePathCasing(uri: URI): boolean;
    	isAbsolutePath(resource: URI): boolean;
    	isEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;
    	isEqualAuthority(a1: string, a2: string): boolean;
    	isEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;
    	joinPath(resource: URI, ...pathFragment: string[]): URI;
    	normalizePath(resource: URI): URI;
    	// (undocumented)
    relativePath(from: URI, to: URI): string | undefined;
    	removeTrailingPathSeparator(resource: URI, sep?: string): URI;
    	resolvePath(base: URI, path: string): URI;
}

// @public (undocumented)
export interface ILimiter<T> {
    	// (undocumented)
    queue(factory: ITask<Promise<T>>): Promise<T>;
    	// (undocumented)
    readonly size: number;
}

// @public (undocumented)
interface INextTask {
    	// (undocumented)
    readonly promise: Promise<void>;
    	// (undocumented)
    readonly promiseReject: (error: Error) => void;
    	// (undocumented)
    readonly promiseResolve: () => void;
    	// (undocumented)
    run: () => Promise<void>;
}

// @public
export class IntervalCounter {
    	constructor(interval: number, nowFn?: () => number);
    	// (undocumented)
    increment(): number;
    	}

// @public (undocumented)
export class IntervalTimer implements IDisposable {
    	constructor();
    	// (undocumented)
    cancel(): void;
    	// (undocumented)
    cancelAndSet(runner: () => void, interval: number): void;
    	// (undocumented)
    dispose(): void;
    	}

// @public (undocumented)
interface IObservable<T, _TChange = void> {
    	addObserver(observer: IObserver): void;
    	// (undocumented)
    readonly debugName: string;
    	get(): T;
    	// (undocumented)
    map<TNew>(fn: (value: T) => TNew): IObservable<TNew>;
    	read(reader: IReader): T;
    	// (undocumented)
    removeObserver(observer: IObserver): void;
    	// (undocumented)
    readonly TChange: _TChange;
}

// @public (undocumented)
interface IObserver {
    	beginUpdate<T>(observable: IObservable<T>): void;
    	endUpdate<T>(observable: IObservable<T>): void;
    	handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;
}

// @public (undocumented)
interface IReader {
    	subscribeTo<T>(observable: IObservable<T, any>): void;
}

// @public (undocumented)
export function isThenable<T>(obj: unknown): obj is Promise<T>;

// @public (undocumented)
export interface ITask<T> {
    	// (undocumented)
    (): T;
}

// @public (undocumented)
export interface ITaskSequentializerWithNextTask {
    	// (undocumented)
    readonly next: INextTask;
}

// @public (undocumented)
export interface ITaskSequentializerWithPendingTask {
    	// (undocumented)
    readonly pending: Promise<void>;
}

// @public (undocumented)
export interface IThrottledWorkerOptions {
    	maxBufferedWork: number | undefined;
    	maxWorkChunkSize: number;
    	throttleDelay: number;
}

// @public
export class Limiter<T> implements ILimiter<T> {
    	constructor(maxDegreeOfParalellism: number);
    	// (undocumented)
    dispose(): void;
    	get onDrained(): Event_2<void>;
    	// (undocumented)
    queue(factory: ITask<Promise<T>>): Promise<T>;
    	// (undocumented)
    get size(): number;
    	}

// @public
export const MicrotaskDelay: unique symbol;

// @public
export class ProcessTimeRunOnceScheduler {
    	constructor(runner: () => void, delay: number);
    	// (undocumented)
    cancel(): void;
    	// (undocumented)
    dispose(): void;
    	isScheduled(): boolean;
    	schedule(delay?: number): void;
    	}

// @public (undocumented)
export namespace Promises {
    	export function settled<T>(promises: Promise<T>[]): Promise<T[]>;
    	export function withAsyncBody<T, E = Error>(
    		bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>,
    	): Promise<T>;
}

// @public
export class Queue<T> extends Limiter<T> {
    	constructor();
}

// @public
export function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T>;

// @public
export function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;

// @public
export function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;

// @public
export function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T>;

// @public (undocumented)
export function raceTimeout<T>(
	promise: Promise<T>,
	timeout: number,
	onTimeout?: () => void,
): Promise<T | undefined>;

// @public
export class ResourceQueue implements IDisposable {
    	// (undocumented)
    dispose(): void;
    	// (undocumented)
    queueFor(resource: URI, extUri?: IExtUri): ILimiter<void>;
    	// (undocumented)
    whenDrained(): Promise<void>;
}

// @public (undocumented)
export function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T>;

// @public (undocumented)
export class RunOnceScheduler implements IDisposable {
    	constructor(runner: (...args: any[]) => void, delay: number);
    	cancel(): void;
    	// (undocumented)
    get delay(): number;
    	set delay(value: number);
    	dispose(): void;
    	// (undocumented)
    protected doRun(): void;
    	// (undocumented)
    flush(): void;
    	isScheduled(): boolean;
    	// (undocumented)
    protected runner: ((...args: unknown[]) => void) | null;
    	schedule(delay?: number): void;
    	}

// @public (undocumented)
export class RunOnceWorker<T> extends RunOnceScheduler {
    	constructor(runner: (units: T[]) => void, timeout: number);
    	// (undocumented)
    dispose(): void;
    	// (undocumented)
    protected doRun(): void;
    	// (undocumented)
    work(unit: T): void;
}

// @public
export let runWhenIdle: (callback: (idle: IdleDeadline_2) => void, timeout?: number) => IDisposable;

// @public
export function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]>;

// @public (undocumented)
export class Sequencer {
    	// (undocumented)
    queue<T>(promiseTask: ITask<Promise<T>>): Promise<T>;
}

// @public (undocumented)
export class SequencerByKey<TKey> {
    	// (undocumented)
    queue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T>;
}

// @public (undocumented)
export class TaskSequentializer {
    	// (undocumented)
    cancelPending(): void;
    	// (undocumented)
    hasNext(): this is ITaskSequentializerWithNextTask;
    	// (undocumented)
    hasPending(taskId?: number): this is ITaskSequentializerWithPendingTask;
    	// (undocumented)
    join(): Promise<void>;
    	// (undocumented)
    get pending(): Promise<void> | undefined;
    	// (undocumented)
    setNext(run: () => Promise<void>): Promise<void>;
    	// (undocumented)
    setPending(taskId: number, promise: Promise<void>, onCancel?: () => void): Promise<void>;
    	}

// @public
export class ThrottledDelayer<T> {
    	constructor(defaultDelay: number);
    	// (undocumented)
    cancel(): void;
    	// (undocumented)
    dispose(): void;
    	// (undocumented)
    isTriggered(): boolean;
    	// (undocumented)
    trigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T>;
}

// @public
export class ThrottledWorker<T> extends Disposable {
    	constructor(options: IThrottledWorkerOptions, handler: (units: T[]) => void);
    	// (undocumented)
    dispose(): void;
    	get pending(): number;
    	work(units: readonly T[]): boolean;
}

// @public
export class Throttler {
    	constructor();
    	// (undocumented)
    queue<T>(promiseFactory: ITask<Promise<T>>): Promise<T>;
    	}

// @public (undocumented)
export function timeout(millis: number): CancelablePromise<void>;

// @public (undocumented)
export function timeout(millis: number, token: CancellationToken): Promise<void>;

// @public (undocumented)
export class TimeoutTimer implements IDisposable {
    	constructor();
    	constructor(runner: () => void, timeout: number);
    	// (undocumented)
    cancel(): void;
    	// (undocumented)
    cancelAndSet(runner: () => void, timeout: number): void;
    	// (undocumented)
    dispose(): void;
    	// (undocumented)
    setIfNotSet(runner: () => void, timeout: number): void;
    	}

// @public
class URI implements UriComponents {
    	// @internal
    protected constructor(
    		scheme: string,
    		authority?: string,
    		path?: string,
    		query?: string,
    		fragment?: string,
    		_strict?: boolean,
    	);
    	// @internal
    protected constructor(components: UriComponents);
    	readonly authority: string;
    	static file(path: string): URI;
    	readonly fragment: string;
    	// (undocumented)
    static from(components: {
        		scheme: string;
        		authority?: string;
        		path?: string;
        		query?: string;
        		fragment?: string;
        	}): URI;
    	get fsPath(): string;
    	// (undocumented)
    static isUri(thing: any): thing is URI;
    	static joinPath(uri: URI, ...pathFragment: string[]): URI;
    	static parse(value: string, _strict?: boolean): URI;
    	readonly path: string;
    	readonly query: string;
    	// (undocumented)
    static revive(data: UriComponents | URI): URI;
    	// (undocumented)
    static revive(data: UriComponents | URI | undefined): URI | undefined;
    	// (undocumented)
    static revive(data: UriComponents | URI | null): URI | null;
    	// (undocumented)
    static revive(data: UriComponents | URI | undefined | null): URI | undefined | null;
    	readonly scheme: string;
    	// (undocumented)
    toJSON(): UriComponents;
    	toString(skipEncoding?: boolean): string;
    	// (undocumented)
    with(change: {
        		scheme?: string;
        		authority?: string | null;
        		path?: string | null;
        		query?: string | null;
        		fragment?: string | null;
        	}): URI;
}

// @public (undocumented)
interface UriComponents {
    	// (undocumented)
    authority: string;
    	// (undocumented)
    fragment: string;
    	// (undocumented)
    path: string;
    	// (undocumented)
    query: string;
    	// (undocumented)
    scheme: string;
}

// @public (undocumented)
export type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;

// (No @packageDocumentation comment for this package)

```
