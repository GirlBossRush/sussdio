## API Report File for "@sussudio/base/common/buffer"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export function bufferedStreamToBuffer(
	bufferedStream: streams.ReadableBufferedStream<VSBuffer>,
): Promise<VSBuffer>;

// @public (undocumented)
export function bufferToReadable(buffer: VSBuffer): VSBufferReadable;

// @public (undocumented)
export function bufferToStream(buffer: VSBuffer): streams.ReadableStream<VSBuffer>;

// @public
function consumeReadable<T>(readable: Readable<T>, reducer: IReducer<T>): T;

// @public
function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer: IReducer<T, R>): Promise<R>;

// @public (undocumented)
function consumeStream(stream: ReadableStreamEvents<unknown>): Promise<undefined>;

// @public
export function decodeBase64(encoded: string): VSBuffer;

// @public
function emptyStream(): ReadableStream_2<never>;

// @public
export function encodeBase64({ buffer }: VSBuffer, padded?: boolean, urlSafe?: boolean): string;

// @public (undocumented)
interface IDataTransformer<Original, Transformed> {
    	// (undocumented)
    (data: Original): Transformed;
}

// @public
interface IDisposable {
    	// (undocumented)
    dispose(): void;
}

// @public (undocumented)
interface IErrorTransformer {
    	// (undocumented)
    (error: Error): Error;
}

// @public (undocumented)
interface IReducer<T, R = T> {
    	// (undocumented)
    (data: T[]): R;
}

// @public (undocumented)
function isReadable<T>(obj: unknown): obj is Readable<T>;

// @public (undocumented)
function isReadableBufferedStream<T>(obj: unknown): obj is ReadableBufferedStream<T>;

// @public (undocumented)
function isReadableStream<T>(obj: unknown): obj is ReadableStream_2<T>;

// @public (undocumented)
interface IStreamListener<T> {
    	onData(data: T): void;
    	onEnd(): void;
    	onError(err: Error): void;
}

// @public (undocumented)
interface ITransformer<Original, Transformed> {
    	// (undocumented)
    data: IDataTransformer<Original, Transformed>;
    	// (undocumented)
    error?: IErrorTransformer;
}

// @public
function listenStream<T>(stream: ReadableStreamEvents<T>, listener: IStreamListener<T>): IDisposable;

// @public (undocumented)
export function newWriteableBufferStream(
	options?: streams.WriteableStreamOptions,
): streams.WriteableStream<VSBuffer>;

// @public (undocumented)
function newWriteableStream<T>(
	reducer: IReducer<T>,
	options?: WriteableStreamOptions,
): WriteableStream<T>;

// @public
function peekReadable<T>(
	readable: Readable<T>,
	reducer: IReducer<T>,
	maxChunks: number,
): T | Readable<T>;

// @public
function peekStream<T>(stream: ReadableStream_2<T>, maxChunks: number): Promise<ReadableBufferedStream<T>>;

// @public (undocumented)
export function prefixedBufferReadable(prefix: VSBuffer, readable: VSBufferReadable): VSBufferReadable;

// @public (undocumented)
export function prefixedBufferStream(prefix: VSBuffer, stream: VSBufferReadableStream): VSBufferReadableStream;

// @public
function prefixedReadable<T>(prefix: T, readable: Readable<T>, reducer: IReducer<T>): Readable<T>;

// @public
function prefixedStream<T>(
	prefix: T,
	stream: ReadableStream_2<T>,
	reducer: IReducer<T>,
): ReadableStream_2<T>;

// @public
interface Readable<T> {
    	read(): T | null;
}

// @public
interface ReadableBufferedStream<T> {
    	buffer: T[];
    	ended: boolean;
    	stream: ReadableStream_2<T>;
}

// @public
interface ReadableStream_2<T> extends ReadableStreamEvents<T> {
    	destroy(): void;
    	pause(): void;
    	removeListener(event: string, callback: Function): void;
    	resume(): void;
}

// @public
type ReadableStreamEventPayload<T> = T | Error | 'end';

// @public (undocumented)
interface ReadableStreamEvents<T> {
    	on(event: 'data', callback: (data: T) => void): void;
    	on(event: 'error', callback: (err: Error) => void): void;
    	on(event: 'end', callback: () => void): void;
}

// @public (undocumented)
export function readableToBuffer(readable: VSBufferReadable): VSBuffer;

// @public (undocumented)
export function readUInt16LE(source: Uint8Array, offset: number): number;

// @public (undocumented)
export function readUInt32BE(source: Uint8Array, offset: number): number;

// @public (undocumented)
export function readUInt32LE(source: Uint8Array, offset: number): number;

// @public (undocumented)
export function readUInt8(source: Uint8Array, offset: number): number;

declare namespace streams {
    export {
        isReadable,
        isReadableStream,
        isReadableBufferedStream,
        newWriteableStream,
        consumeReadable,
        peekReadable,
        consumeStream,
        listenStream,
        peekStream,
        toStream,
        emptyStream,
        toReadable,
        transform,
        prefixedReadable,
        prefixedStream,
        ReadableStreamEventPayload,
        ReadableStreamEvents,
        ReadableStream_2 as ReadableStream,
        Readable,
        WriteableStream,
        ReadableBufferedStream,
        IReducer,
        IDataTransformer,
        IErrorTransformer,
        ITransformer,
        WriteableStreamOptions,
        IStreamListener
    }
}

// @public (undocumented)
export function streamToBuffer(stream: streams.ReadableStream<VSBuffer>): Promise<VSBuffer>;

// @public (undocumented)
export function streamToBufferReadableStream(
	stream: streams.ReadableStreamEvents<Uint8Array | string>,
): streams.ReadableStream<VSBuffer>;

// @public
function toReadable<T>(t: T): Readable<T>;

// @public
function toStream<T>(t: T, reducer: IReducer<T>): ReadableStream_2<T>;

// @public
function transform<Original, Transformed>(
	stream: ReadableStreamEvents<Original>,
	transformer: ITransformer<Original, Transformed>,
	reducer: IReducer<Transformed>,
): ReadableStream_2<Transformed>;

// @public (undocumented)
export class VSBuffer {
    	static alloc(byteLength: number): VSBuffer;
    	// (undocumented)
    readonly buffer: Uint8Array;
    	// (undocumented)
    readonly byteLength: number;
    	clone(): VSBuffer;
    	static concat(buffers: VSBuffer[], totalLength?: number): VSBuffer;
    	static fromByteArray(source: number[]): VSBuffer;
    	static fromString(
    		source: string,
    		options?: {
        			dontUseNodeBuffer?: boolean;
        		},
    	): VSBuffer;
    	// (undocumented)
    readUInt32BE(offset: number): number;
    	// (undocumented)
    readUInt32LE(offset: number): number;
    	// (undocumented)
    readUInt8(offset: number): number;
    	// (undocumented)
    set(array: VSBuffer, offset?: number): void;
    	// (undocumented)
    set(array: Uint8Array, offset?: number): void;
    	// (undocumented)
    set(array: ArrayBuffer, offset?: number): void;
    	// (undocumented)
    set(array: ArrayBufferView, offset?: number): void;
    	// (undocumented)
    set(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void;
    	// (undocumented)
    slice(start?: number, end?: number): VSBuffer;
    	// (undocumented)
    toString(): string;
    	static wrap(actual: Uint8Array): VSBuffer;
    	// (undocumented)
    writeUInt32BE(value: number, offset: number): void;
    	// (undocumented)
    writeUInt32LE(value: number, offset: number): void;
    	// (undocumented)
    writeUInt8(value: number, offset: number): void;
}

// @public (undocumented)
export interface VSBufferReadable extends streams.Readable<VSBuffer> {}

// @public (undocumented)
export interface VSBufferReadableBufferedStream extends streams.ReadableBufferedStream<VSBuffer> {}

// @public (undocumented)
export interface VSBufferReadableStream extends streams.ReadableStream<VSBuffer> {}

// @public (undocumented)
export interface VSBufferWriteableStream extends streams.WriteableStream<VSBuffer> {}

// @public
interface WriteableStream<T> extends ReadableStream_2<T> {
    	end(result?: T): void;
    	error(error: Error): void;
    	write(data: T): void | Promise<void>;
}

// @public (undocumented)
interface WriteableStreamOptions {
    	highWaterMark?: number;
}

// @public (undocumented)
export function writeUInt16LE(destination: Uint8Array, value: number, offset: number): void;

// @public (undocumented)
export function writeUInt32BE(destination: Uint8Array, value: number, offset: number): void;

// @public (undocumented)
export function writeUInt32LE(destination: Uint8Array, value: number, offset: number): void;

// @public (undocumented)
export function writeUInt8(destination: Uint8Array, value: number, offset: number): void;

// (No @packageDocumentation comment for this package)

```
