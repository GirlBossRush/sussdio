## API Report File for "@sussudio/base/common/marshalling"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
type Deserialize<T> = T extends UriComponents
	? URI
	: T extends VSBuffer
	? VSBuffer
	: T extends object
	? Revived<T>
	: T;

// @public (undocumented)
const enum MarshalledId {
    	// (undocumented)
    CommentController = 6,
    	// (undocumented)
    CommentNode = 10,
    	// (undocumented)
    CommentThread = 7,
    	// (undocumented)
    CommentThreadInstance = 8,
    	// (undocumented)
    CommentThreadNode = 11,
    	// (undocumented)
    CommentThreadReply = 9,
    	// (undocumented)
    Date = 16,
    	// (undocumented)
    NotebookActionContext = 14,
    	// (undocumented)
    NotebookCellActionContext = 13,
    	// (undocumented)
    Regexp = 2,
    	// (undocumented)
    ScmProvider = 5,
    	// (undocumented)
    ScmResource = 3,
    	// (undocumented)
    ScmResourceGroup = 4,
    	// (undocumented)
    TestItemContext = 15,
    	// (undocumented)
    TimelineActionContext = 12,
    	// (undocumented)
    Uri = 1,
}

// @public (undocumented)
export interface MarshalledObject {
    	// (undocumented)
    $mid: MarshalledId;
}

// @public (undocumented)
export function parse(text: string): any;

// @public (undocumented)
export function revive<T = any>(obj: any, depth?: number): Revived<T>;

// @public (undocumented)
export type Revived<T> = {
    	[K in keyof T]: Deserialize<T[K]>;
};

// @public (undocumented)
export function stringify(obj: any): string;

// @public
class URI implements UriComponents {
    	// @internal
    protected constructor(
    		scheme: string,
    		authority?: string,
    		path?: string,
    		query?: string,
    		fragment?: string,
    		_strict?: boolean,
    	);
    	// @internal
    protected constructor(components: UriComponents);
    	readonly authority: string;
    	static file(path: string): URI;
    	readonly fragment: string;
    	// (undocumented)
    static from(components: {
        		scheme: string;
        		authority?: string;
        		path?: string;
        		query?: string;
        		fragment?: string;
        	}): URI;
    	get fsPath(): string;
    	// (undocumented)
    static isUri(thing: any): thing is URI;
    	static joinPath(uri: URI, ...pathFragment: string[]): URI;
    	static parse(value: string, _strict?: boolean): URI;
    	readonly path: string;
    	readonly query: string;
    	// (undocumented)
    static revive(data: UriComponents | URI): URI;
    	// (undocumented)
    static revive(data: UriComponents | URI | undefined): URI | undefined;
    	// (undocumented)
    static revive(data: UriComponents | URI | null): URI | null;
    	// (undocumented)
    static revive(data: UriComponents | URI | undefined | null): URI | undefined | null;
    	readonly scheme: string;
    	// (undocumented)
    toJSON(): UriComponents;
    	toString(skipEncoding?: boolean): string;
    	// (undocumented)
    with(change: {
        		scheme?: string;
        		authority?: string | null;
        		path?: string | null;
        		query?: string | null;
        		fragment?: string | null;
        	}): URI;
}

// @public (undocumented)
interface UriComponents {
    	// (undocumented)
    authority: string;
    	// (undocumented)
    fragment: string;
    	// (undocumented)
    path: string;
    	// (undocumented)
    query: string;
    	// (undocumented)
    scheme: string;
}

// @public (undocumented)
class VSBuffer {
    	static alloc(byteLength: number): VSBuffer;
    	// (undocumented)
    readonly buffer: Uint8Array;
    	// (undocumented)
    readonly byteLength: number;
    	clone(): VSBuffer;
    	static concat(buffers: VSBuffer[], totalLength?: number): VSBuffer;
    	static fromByteArray(source: number[]): VSBuffer;
    	static fromString(
    		source: string,
    		options?: {
        			dontUseNodeBuffer?: boolean;
        		},
    	): VSBuffer;
    	// (undocumented)
    readUInt32BE(offset: number): number;
    	// (undocumented)
    readUInt32LE(offset: number): number;
    	// (undocumented)
    readUInt8(offset: number): number;
    	// (undocumented)
    set(array: VSBuffer, offset?: number): void;
    	// (undocumented)
    set(array: Uint8Array, offset?: number): void;
    	// (undocumented)
    set(array: ArrayBuffer, offset?: number): void;
    	// (undocumented)
    set(array: ArrayBufferView, offset?: number): void;
    	// (undocumented)
    set(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void;
    	// (undocumented)
    slice(start?: number, end?: number): VSBuffer;
    	// (undocumented)
    toString(): string;
    	static wrap(actual: Uint8Array): VSBuffer;
    	// (undocumented)
    writeUInt32BE(value: number, offset: number): void;
    	// (undocumented)
    writeUInt32LE(value: number, offset: number): void;
    	// (undocumented)
    writeUInt8(value: number, offset: number): void;
}

// (No @packageDocumentation comment for this package)

```
